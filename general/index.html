<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General usage · GAIO.jl</title><meta name="title" content="General usage · GAIO.jl"/><meta property="og:title" content="General usage · GAIO.jl"/><meta property="twitter:title" content="General usage · GAIO.jl"/><meta name="description" content="Documentation for GAIO.jl."/><meta property="og:description" content="Documentation for GAIO.jl."/><meta property="twitter:description" content="Documentation for GAIO.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>General usage</a><ul class="internal"><li><a class="tocitem" href="#Box"><span>Box</span></a></li><li><a class="tocitem" href="#BoxGrid"><span>BoxGrid</span></a></li><li><a class="tocitem" href="#BoxTree"><span>BoxTree</span></a></li><li><a class="tocitem" href="#BoxSet"><span>BoxSet</span></a></li><li><a class="tocitem" href="#BoxMap"><span>BoxMap</span></a></li><li><a class="tocitem" href="#TransferOperator"><span>TransferOperator</span></a></li><li><a class="tocitem" href="#BoxMeasure"><span>BoxMeasure</span></a></li><li><a class="tocitem" href="#Graphs-of-Boxes"><span>Graphs of Boxes</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../DynamicalSystems/">DynamicalSystems.jl</a></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../algorithms/limit_sets/">Limit Sets and Attractors</a></li><li><a class="tocitem" href="../algorithms/recurrent_set/">Reccurent Set</a></li><li><a class="tocitem" href="../algorithms/unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../algorithms/transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../algorithms/almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../algorithms/cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../algorithms/coherent/">Coherent Sets</a></li><li><a class="tocitem" href="../algorithms/seba/">Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../algorithms/box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../algorithms/ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Conley-Morse Theory</span><ul><li><a class="tocitem" href="../algorithms/morse_graph/">Morse Graph</a></li><li><a class="tocitem" href="../algorithms/conley_index/">Conley Index</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../algorithms/root_covering/">Root Covering</a></li><li><a class="tocitem" href="../algorithms/implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li><li><a class="tocitem" href="../metal/">Using the GPU (Metal)</a></li></ul></li><li><a class="tocitem" href="../examples/">Other Examples</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><a class="tocitem" href="../library_reference/">Library Reference</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>General usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>General usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/general.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>The base of the set oriented framework are <code>BoxSet</code>s (as a discretization of state space) and <code>BoxMap</code>s (as a discretization of a map). In the following, we will have a closer look at the two concepts and other useful things to know when using GAIO.jl. </p><h2 id="Box"><a class="docs-heading-anchor" href="#Box">Box</a><a id="Box-1"></a><a class="docs-heading-anchor-permalink" href="#Box" title="Permalink"></a></h2><p>To create a <code>Box</code> with center <code>c</code><span>$\in\mathbb{R}^d$</span> and radius <code>r</code><span>$\in\mathbb{R}^d$</span>, type </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using GAIO</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c, r = (0.5, 0.5), (0.5, 0.5)</code><code class="nohighlight hljs ansi" style="display:block;">((0.5, 0.5), (0.5, 0.5))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box = Box(c, r)</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.5, 0.5]
   radius: [0.5, 0.5]</code></pre><p>This creates the set <span>$box = [c_1 - r_1, c_1 + r_1) \times \ldots \times [c_d - r_d, c_d + r_d)$</span>. Conversely, one can get back the vectors <code>c</code> and <code>r</code> from a box <span>$box$</span> by </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c, r = box</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.5, 0.5]
   radius: [0.5, 0.5]</code></pre><h2 id="BoxGrid"><a class="docs-heading-anchor" href="#BoxGrid">BoxGrid</a><a id="BoxGrid-1"></a><a class="docs-heading-anchor-permalink" href="#BoxGrid" title="Permalink"></a></h2><p>Most algorithms in GAIO.jl revolve around a partition <span>$\scr P$</span>  of some domain <span>$X\subset\mathbb{R}^d$</span> into small boxes.  Often, the domain <code>X</code> is a <code>Box</code> and the partition <code>𝒫</code> is a grid of boxes on <code>X</code>. To create an <span>$n_1 \times \ldots \times n_d$</span>-element grid of boxes on a box <code>X</code>, pass <code>X</code> and the tuple <code>n = (n_1,...,n_d)</code> to the function <code>BoxGrid</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; X = box     # domain</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.5, 0.5]
   radius: [0.5, 0.5]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = (4, 2)</code><code class="nohighlight hljs ansi" style="display:block;">(4, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒫 = BoxGrid(X, n)</code><code class="nohighlight hljs ansi" style="display:block;">4 x 2 - element BoxGrid</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = (0.2, 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">(0.2, 0.1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; key = point_to_key(𝒫, x)    # x is some point in the domain Q</code><code class="nohighlight hljs ansi" style="display:block;">(1, 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box = key_to_box(𝒫, key)    # cover the point x with a box from P</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.125, 0.25]
   radius: [0.125, 0.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box = point_to_box(𝒫, x)    # performs both above functions</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.125, 0.25]
   radius: [0.125, 0.25]</code></pre><h2 id="BoxTree"><a class="docs-heading-anchor" href="#BoxTree">BoxTree</a><a id="BoxTree-1"></a><a class="docs-heading-anchor-permalink" href="#BoxTree" title="Permalink"></a></h2><p>For partitions of <code>X</code> into variably sized boxes, one can use <code>BoxTree</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒫_tree = BoxTree(X)</code><code class="nohighlight hljs ansi" style="display:block;">BoxTree of depth 1</code></pre><p>A <code>BoxTree</code> uses a binary tree structure to store a box partition of the domain.  One can refine a  partition by bisecting all boxes in <code>𝒫</code> along the <span>$i$</span>-th coordinate direction through </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; i = 1   # for example, the first coord. direction</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subdivide!(𝒫_tree, i)</code><code class="nohighlight hljs ansi" style="display:block;">BoxTree of depth 2</code></pre><h2 id="BoxSet"><a class="docs-heading-anchor" href="#BoxSet">BoxSet</a><a id="BoxSet-1"></a><a class="docs-heading-anchor-permalink" href="#BoxSet" title="Permalink"></a></h2><p>A core idea of GAIO.jl is to approximate a subset of the domain <span>$X$</span> via a collection of boxes. To construct a <code>BoxSet</code>, there are two typical options: retrieving all boxes from some partition, or locating a box surrounding a (or some) point(s) in <span>$X$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℬ = cover(𝒫, :)    # set of all boxes from 𝒫</code><code class="nohighlight hljs ansi" style="display:block;">8 - element BoxSet in 4 x 2 - element BoxGrid</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = (0.2, 0.4)</code><code class="nohighlight hljs ansi" style="display:block;">(0.2, 0.4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℬ = cover(𝒫, x)    # set of one box containing the point x</code><code class="nohighlight hljs ansi" style="display:block;">1 - element BoxSet in 4 x 2 - element BoxGrid</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xs = [ rand(2) for _=1:10 ]</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{Vector{Float64}}:
 [0.4104487213533434, 0.6715579510521669]
 [0.7297152164102118, 0.5557945832036757]
 [0.24328435218827005, 0.25595487349795976]
 [0.5672718935431247, 0.681494004427259]
 [0.24670790028175893, 0.6725620469975685]
 [0.7989235148893963, 0.9184485226417728]
 [0.8685388732724504, 0.6483951557602743]
 [0.9125699137622358, 0.5005304004981266]
 [0.9797181880823621, 0.4181464210479745]
 [0.037650057354620015, 0.7697134903191377]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℬ = cover(𝒫, xs)   # set of boxes containing the points in xs</code><code class="nohighlight hljs ansi" style="display:block;">6 - element BoxSet in 4 x 2 - element BoxGrid</code></pre><p>You can access the boxes or their internal data via iteration</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for box in ℬ
           center, radius = box
           # do something
       end
       
       # get an array of boxes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; arr_of_boxes = collect(ℬ)
       
       # get an array of box centers</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Box{2, Float64}}:
 [0.5, 0.75) × [0.5, 1.0)
 [0.0, 0.25) × [0.5, 1.0)
 [0.0, 0.25) × [0.0, 0.5)
 [0.75, 1.0) × [0.5, 1.0)
 [0.75, 1.0) × [0.0, 0.5)
 [0.25, 0.5) × [0.5, 1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; arr_of_centers = collect(box.center for box in ℬ)
       
       # get an array of box radii</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{SVector{2, Float64}}:
 [0.625, 0.75]
 [0.125, 0.75]
 [0.125, 0.25]
 [0.875, 0.75]
 [0.875, 0.25]
 [0.375, 0.75]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; arr_of_radii = collect(box.radius for box in ℬ)</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{SVector{2, Float64}}:
 [0.125, 0.25]
 [0.125, 0.25]
 [0.125, 0.25]
 [0.125, 0.25]
 [0.125, 0.25]
 [0.125, 0.25]</code></pre><h2 id="BoxMap"><a class="docs-heading-anchor" href="#BoxMap">BoxMap</a><a id="BoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#BoxMap" title="Permalink"></a></h2><p>A box map is a function which maps a <code>BoxSet</code> to a <code>BoxSet</code>. Given a map <span>$f : \mathbb{R}^d\to \mathbb{R}^d$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f((x,y)) = (1-1.4*x^2+y, 0.3*x)   # the Hénon map</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code></pre><p>and some box <code>X</code> as domain, you construct a <code>BoxMap</code> by</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; F = BoxMap(f, X)</code><code class="nohighlight hljs ansi" style="display:block;">BoxMap over [0.0, 1.0) × [0.0, 1.0)</code></pre><p>By default, GAIO.jl will try to adaptively choose sample points in a set to compute the image of the set by approximating the (local) Lipschitz constant of the map <span>$f$</span>. There are many other types of <code>BoxMap</code> discretizations available, see the <a href="../boxmaps/boxmaps_general/">section on BoxMaps</a>. </p><p>We can now map a <code>BoxSet ℬ</code> via the <code>BoxMap F</code> by</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒞 = F(ℬ)</code><code class="nohighlight hljs ansi" style="display:block;">8 - element BoxSet in 4 x 2 - element BoxGrid</code></pre><p>where the output <code>𝒞</code> is also a <code>BoxSet</code>.</p><p>For long running computations, you can also display a progress meter</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ProgressMeter</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒞 = F(ℬ; show_progress = true)</code><code class="nohighlight hljs ansi" style="display:block;">8 - element BoxSet in 4 x 2 - element BoxGrid</code></pre><h2 id="TransferOperator"><a class="docs-heading-anchor" href="#TransferOperator">TransferOperator</a><a id="TransferOperator-1"></a><a class="docs-heading-anchor-permalink" href="#TransferOperator" title="Permalink"></a></h2><p>The <em>Perron-Frobenius operator</em> (or <em>transfer operator</em>) [[<a href="../references/#lasotamackey">5</a>]] associated to a map <span>$f$</span> can be approximated using the <code>TransferOperator</code> type.  To construct a (discretized) <code>TransferOperator</code> from a <code>BoxMap</code> <span>$F$</span> on the domain <code>BoxSet</code> <code>ℬ</code>, you type</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒫 = BoxGrid(X, (20,20))     # 20 x 20 so there&#39;s more going on</code><code class="nohighlight hljs ansi" style="display:block;">20 x 20 - element BoxGrid</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℬ = cover(𝒫, :)             # cover the whole partition</code><code class="nohighlight hljs ansi" style="display:block;">400 - element BoxSet in 20 x 20 - element BoxGrid</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = TransferOperator(F, ℬ, ℬ)</code><code class="nohighlight hljs ansi" style="display:block;">400 x 400 TransferOperator over 20 x 20 - element BoxGrid with 1392 stored entries:

⎡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠠⠀⠄⠠⠀⠀⠄⠢⠄⠀⠐⠂⡄⠠⠂⠀⠠⠠⠢⠀⠤⠤⠐⠀⠀⠤⠀⠀⠀⠤⠤⠀⠂⠀⠠⠀⠀⠴⠆⡠⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠂⠀⠂⠀⡀⠂⡐⢐⠀⠀⠂⠒⠂⠀⠐⠒⢀⠐⢀⢂⠀⠐⠂⢒⠒⠀⠂⡀⣀⢀⠀⠀⢀⠀⠀⢀⡀⢀⎥
⎢⠀⠀⠁⠀⠀⠀⠀⠀⠀⠐⠀⢀⢁⢂⠀⠀⠐⠀⠀⠀⠀⡂⣘⠂⢀⡀⡐⡀⠀⢀⡀⡀⢀⣀⢀⢀⠀⠀⠀⠁⎥
⎢⠀⠠⡄⠡⡄⠀⠀⡉⢨⠀⠬⠠⠀⠠⡅⠄⠠⠄⠁⢨⠄⠡⠥⠨⡠⠥⠅⠄⡥⠠⠁⠥⡩⠤⠥⠈⠀⠈⠁⠀⎥
⎢⢐⣓⠃⠐⠀⠀⠀⠐⠀⡃⠀⡠⠂⡓⠀⠀⠐⠐⠄⠀⠂⠂⢼⠀⠠⠆⠀⠄⠀⠰⡂⠀⠀⢘⡀⢠⠀⠂⠀⠑⎥
⎢⠠⢤⠄⢁⢄⠀⢈⢀⢈⠄⡀⠌⠈⣄⡀⢄⠀⢠⡁⢨⡀⣁⡩⢈⠌⣁⠅⠁⣄⠈⡍⢁⢈⠁⡁⠈⡀⠠⡀⠀⎥
⎢⣬⢨⡄⡄⣤⠀⠀⠀⠀⡄⡌⡅⣄⢁⢀⠀⢠⣀⡀⡀⢠⢠⡎⢠⢀⡂⢠⢢⠁⢠⠁⡤⡄⣠⢂⢰⢠⢈⢡⣀⎥
⎢⠐⢐⡄⢀⡂⠀⠀⡀⢀⠔⣐⠂⠄⢂⡀⠂⢐⡐⡂⠐⡀⢂⠲⢂⡂⣀⠒⠀⣀⠀⠀⠐⡒⠠⠀⠂⠀⠐⠂⠔⎥
⎢⣉⢨⡀⡁⠌⠀⡀⢀⢀⡅⢁⢄⣥⢠⠀⡈⠨⣁⡁⣀⡠⣌⡥⢨⢀⡀⡬⣬⢁⣈⣄⣭⣡⣭⡠⢈⠡⢈⠈⠁⎥
⎢⠀⠰⠄⠠⠂⠀⠠⠠⠠⠂⠔⠂⠀⠰⠄⠂⠐⠠⠄⠀⠔⠠⠀⠠⠀⠦⠒⠒⠴⠀⠀⠒⠐⠒⠐⠀⠐⠀⠀⠐⎥
⎢⣒⢲⡂⡖⢒⠁⠚⠒⠚⠄⡒⠊⡤⠒⠂⠀⠰⢗⠗⢪⠓⢖⡴⢰⠘⡖⠶⠤⠐⢚⠞⢤⣎⣤⠑⢀⠀⢐⣂⣐⎥
⎢⠉⠀⠅⠫⠨⠀⠢⠸⠁⠨⠁⠀⠗⠜⠌⠠⠨⠧⠊⠒⠭⠯⠪⠰⠐⠨⠨⠨⠀⠊⠯⠐⠒⠈⠪⠈⠄⠕⠎⠈⎥
⎢⠚⠐⡃⠒⡙⠀⠔⡰⢄⠠⠃⠁⠂⡢⠈⠑⠘⠒⠣⢄⠨⠐⠄⠀⡠⠑⡘⠐⡑⠜⠴⠡⠢⠋⠨⠘⠂⠲⠖⠪⎥
⎢⠛⠺⠅⠳⣐⠀⠲⠴⠣⠨⢦⡀⠃⢺⠆⡰⢀⠺⡞⠂⢮⠸⠈⠠⠐⡿⢸⡸⢶⠚⠽⣀⠇⡛⢨⢀⠆⠸⠄⢙⎥
⎢⠩⣥⡅⠩⠡⠄⠠⠩⠈⡅⠁⠄⠄⡭⠁⠰⠨⠍⠆⠈⠅⠕⢨⠈⠁⠹⠙⠐⠁⠈⡵⠀⠡⢨⠀⠀⠂⠌⠀⠩⎥
⎢⢰⢒⡆⢒⢲⠀⢒⢐⠂⠒⢄⡂⡂⡒⠢⠊⢐⣒⡓⠒⠂⢂⢒⠐⠒⢐⠚⠈⢃⠢⡒⠐⠒⠠⠀⠠⠁⣒⡂⠐⎥
⎢⣐⡐⡀⡐⡐⠀⠐⢐⠀⡀⠒⠂⡂⣂⠂⡀⠀⢒⠂⢀⡂⢐⢐⠀⡀⡐⡀⠀⠐⢀⠀⠀⡂⣀⠀⡀⠀⢐⠂⣀⎥
⎣⠀⠀⠄⠀⠀⠀⠀⠄⠠⠨⠠⠀⠀⠠⠄⠀⠠⠤⠄⠀⠀⠄⠀⠠⠄⠤⠤⠀⠄⠀⠀⠈⠄⠀⠀⠀⠀⠀⠀⠀⎦</code></pre><p>Again, a progress meter can be displayed with the additional keyword argument <code>show_progress = true</code>.</p><p>Formally, <code>T</code> is a linear (in fact, a Markov) operator on the space of steps functions on the box set ℬ.  Of particular interest are often certain eigenvectors. For example, an eigenvector at the eigenvalue 1 is an (approximate) invariant measure, which characterizes the long term behaviour of <span>$f$</span> according to <a href="https://en.wikipedia.org/wiki/Birkhoff%27s_ergodic_theorem">Birkhoff&#39;s ergodic theorem</a>. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; λ, ev = eigs(T)</code><code class="nohighlight hljs ansi" style="display:block;">(ComplexF64[0.6024149797975805 + 0.0im, -0.293057626130105 + 0.0im, 0.10206207261597958 + 0.0im], BoxMeasure{Box{2, Float64}, Tuple{Int64, Int64}, ComplexF64, BoxGrid{2, Float64, Int64}, OrderedCollections.OrderedDict{Tuple{Int64, Int64}, ComplexF64}}[BoxMeasure in 20 x 20 - element BoxGrid with 400 boxes in its suport, BoxMeasure in 20 x 20 - element BoxGrid with 400 boxes in its suport, BoxMeasure in 20 x 20 - element BoxGrid with 400 boxes in its suport], 3, 1, 20, [1.3480855942419456e-7, -2.5156626722598564e-8, -9.08398430559264e-8, 4.397254943258681e-8, 1.723191910927363e-7, 1.7245427819635085e-8, -1.1679581193354769e-7, 8.706224017991166e-8, -7.292880156621694e-9, 7.971422625606301e-10  …  -9.408707674202613e-8, 2.186307394178859e-8, -8.495220030844801e-7, -1.992036070301162e-5, 1.3587462373948192e-7, 5.527422893691085e-8, -4.9106579924733965e-8, 7.430098308410094e-8, 1.6611550650774443e-8, 1.8986434129292708e-7])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; μ = ev[1]   # ev is an array of measures, grab the first one</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 20 x 20 - element BoxGrid with 400 boxes in its suport</code></pre><p>This can also be done with the adjoint <em>Koopman operator</em> <code>T&#39;</code>. </p><h2 id="BoxMeasure"><a class="docs-heading-anchor" href="#BoxMeasure">BoxMeasure</a><a id="BoxMeasure-1"></a><a class="docs-heading-anchor-permalink" href="#BoxMeasure" title="Permalink"></a></h2><p>The second output of <code>eigs(T)</code> is a vector of (discrete) measures, <code>BoxMeasure</code>s. A <code>BoxMeasure</code>  is absolutely continuous w.r.t. the volume (i.e. Lebesgue) measure and its density is piecewise constant on the boxes of the domain ℬ. One can let <code>T</code> act on a <code>BoxMeasure</code> simply through multiplication</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν = T*μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 20 x 20 - element BoxGrid with 90 boxes in its suport</code></pre><p>Of course, the same holds for the the Koopman operator as well. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν = T&#39;*μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 20 x 20 - element BoxGrid with 182 boxes in its suport</code></pre><p>One can evaulate a <code>BoxMeasure</code> on an arbitrary <code>BoxSet</code> ℬ</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; μ(ℬ)</code><code class="nohighlight hljs ansi" style="display:block;">6.335723408296507 + 0.0im</code></pre><p>Similarly, one can integrate a function with respect to a BoxMeasure via</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(x -&gt; sin(x[1] + 2x[2]), μ)</code><code class="nohighlight hljs ansi" style="display:block;">5.036354373963653 + 0.0im</code></pre><p>Marginal distributions can be accessed using the <code>marginal</code> function</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; marginal(μ; dim=1)</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 20 - element BoxGrid with 20 boxes in its suport</code></pre><p>The measures can also be associated with a (Lebesgue) density</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = density(μ)</code><code class="nohighlight hljs ansi" style="display:block;">(::GAIO.var&quot;#eval_density#162&quot;{BoxMeasure{Box{2, Float64}, Tuple{Int64, Int64}, ComplexF64, BoxGrid{2, Float64, Int64}, OrderedCollections.OrderedDict{Tuple{Int64, Int64}, ComplexF64}}, BoxGrid{2, Float64, Int64}}) (generic function with 1 method)</code></pre><p>Since a measure μ is a function defined over measurable sets, composite measures <span>$g \circ \mu$</span> are well-defined for functions <span>$g : \mathbb{R} \to \mathbb{R}$</span> (or <span>$g : \mathbb{C} \to \mathbb{C}$</span>). This is supported in GAIO.jl for <code>BoxMeasures</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; η = exp ∘ μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 20 x 20 - element BoxGrid with 400 boxes in its suport</code></pre><p>Finite signed measures can be given a vector space structure. This is also supported:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν + μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 20 x 20 - element BoxGrid with 400 boxes in its suport</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2ν - μ/2</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 20 x 20 - element BoxGrid with 400 boxes in its suport</code></pre><h2 id="Graphs-of-Boxes"><a class="docs-heading-anchor" href="#Graphs-of-Boxes">Graphs of Boxes</a><a id="Graphs-of-Boxes-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs-of-Boxes" title="Permalink"></a></h2><p>One can equivalently view the transfer operator as a weighted directed graph. That is, the matrix of a <code>TrensferOperator</code> is the (transposed) weighted adjacency matrix for a graph. This graph can be constructed explicitely using the <code>MetaGraphsNext.jl</code> package </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Graphs, MetaGraphsNext</code><code class="nohighlight hljs ansi" style="display:block;">WARNING: using Graphs.density in module Main conflicts with an existing identifier.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; G = MetaGraph(T)</code><code class="nohighlight hljs ansi" style="display:block;">Meta graph based on a SimpleDiGraph{Int64} with vertex labels of type Tuple{Int64, Int64}, vertex metadata of type Nothing, edge metadata of type Float64, graph metadata given by 20 x 20 - element BoxGrid, and default weight 1.0</code></pre><p>See also the <a href="https://juliagraphs.org/Graphs.jl/stable/">Graphs</a> and <a href="https://juliagraphs.org/MetaGraphsNext.jl/stable/">MetaGraphsNext</a> documentation. </p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>GAIO.jl offers both <code>Plots</code> or <code>Makie</code> for plotting. To plot a <code>BoxSet</code> or a <code>BoxMeasure</code>, simply choose either Plots or a Makie backend, eg. <code>GLMakie</code>, and call <code>plot</code> on a <code>BoxSet</code> or <code>BoxMeasure</code></p><pre><code class="language-julia hljs">using GLMakie: plot

plot(ℬ)
plot(μ)</code></pre><p>Plotting works with all the functionality of either package. This means you can set box plots as subplots, add colorbars, etc., using the Plots or Makie interface. For an example, see <code>examples/invariant_measure_2d.jl</code>. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting started</a><a class="docs-footer-nextpage" href="../DynamicalSystems/">DynamicalSystems.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 22 September 2025 07:30">Monday 22 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
