<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General usage · GAIO.jl</title><meta name="title" content="General usage · GAIO.jl"/><meta property="og:title" content="General usage · GAIO.jl"/><meta property="twitter:title" content="General usage · GAIO.jl"/><meta name="description" content="Documentation for GAIO.jl."/><meta property="og:description" content="Documentation for GAIO.jl."/><meta property="twitter:description" content="Documentation for GAIO.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>General usage</a><ul class="internal"><li><a class="tocitem" href="#Box"><span>Box</span></a></li><li><a class="tocitem" href="#BoxGrid"><span>BoxGrid</span></a></li><li><a class="tocitem" href="#BoxTree"><span>BoxTree</span></a></li><li><a class="tocitem" href="#BoxSet"><span>BoxSet</span></a></li><li><a class="tocitem" href="#BoxMap"><span>BoxMap</span></a></li><li><a class="tocitem" href="#TransferOperator"><span>TransferOperator</span></a></li><li><a class="tocitem" href="#BoxMeasure"><span>BoxMeasure</span></a></li><li><a class="tocitem" href="#Graphs-of-Boxes"><span>Graphs of Boxes</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../algorithms/limit_sets/">Limit Sets and Attractors</a></li><li><a class="tocitem" href="../algorithms/recurrent_set/">Reccurent Set</a></li><li><a class="tocitem" href="../algorithms/unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../algorithms/transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../algorithms/almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../algorithms/cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../algorithms/coherent/">Coherent Sets</a></li><li><a class="tocitem" href="../algorithms/seba/">Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../algorithms/box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../algorithms/ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Conley-Morse Theory</span><ul><li><a class="tocitem" href="../algorithms/morse_graph/">Morse Graph</a></li><li><a class="tocitem" href="../algorithms/conley_index/">Conley Index</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../algorithms/root_covering/">Root Covering</a></li><li><a class="tocitem" href="../algorithms/implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li><li><a class="tocitem" href="../metal/">Using the GPU (Metal)</a></li></ul></li><li><a class="tocitem" href="../examples/">Other Examples</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><a class="tocitem" href="../library_reference/">Library Reference</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>General usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>General usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/general.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>The base of the set oriented framework are <code>BoxSet</code>s (as a discretization of state space) and <code>BoxMap</code>s (as a discretization of a map). In the following, we will have a closer look at the two concepts and other useful things to know when using GAIO.jl. </p><h2 id="Box"><a class="docs-heading-anchor" href="#Box">Box</a><a id="Box-1"></a><a class="docs-heading-anchor-permalink" href="#Box" title="Permalink"></a></h2><p>To create a <code>Box</code> with center <code>c</code><span>$\in\mathbb{R}^d$</span> and radius <code>r</code><span>$\in\mathbb{R}^d$</span>, type </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using GAIO</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c, r = (0.5, 0.5), (0.5, 0.5)</code><code class="nohighlight hljs ansi" style="display:block;">((0.5, 0.5), (0.5, 0.5))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box = Box(c, r)</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.5, 0.5]
   radius: [0.5, 0.5]</code></pre><p>This creates the set <span>$box = [c_1 - r_1, c_1 + r_1) \times \ldots \times [c_d - r_d, c_d + r_d)$</span>. Conversely, one can get back the vectors <code>c</code> and <code>r</code> from a box <span>$box$</span> by </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c, r = box</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.5, 0.5]
   radius: [0.5, 0.5]</code></pre><h2 id="BoxGrid"><a class="docs-heading-anchor" href="#BoxGrid">BoxGrid</a><a id="BoxGrid-1"></a><a class="docs-heading-anchor-permalink" href="#BoxGrid" title="Permalink"></a></h2><p>Most algorithms in GAIO.jl revolve around a partition <span>$\scr P$</span>  of some domain <span>$X\subset\mathbb{R}^d$</span> into small boxes.  Often, the domain <code>X</code> is a <code>Box</code> and the partition <code>𝒫</code> is a grid of boxes on <code>X</code>. To create an <span>$n_1 \times \ldots \times n_d$</span>-element grid of boxes on a box <code>X</code>, pass <code>X</code> and the tuple <code>n = (n_1,...,n_d)</code> to the function <code>BoxGrid</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = (4, 2)</code><code class="nohighlight hljs ansi" style="display:block;">(4, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒫 = BoxGrid(X, n)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `X` not defined</code></pre><p>&lt;!–<code>BoxGrid</code>s use a cartesian indexing structure to be memory-efficient. These indices are accessed and used through the API:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = (0.2, 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">(0.2, 0.1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; key = point_to_key(P, x)    # x is some point in the domain Q</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `P` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box = key_to_box(P, key)    # cover the point x with a box from P</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `P` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box = point_to_box(P, x)    # performs both above functions</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `P` not defined</code></pre><p>–&gt;</p><h2 id="BoxTree"><a class="docs-heading-anchor" href="#BoxTree">BoxTree</a><a id="BoxTree-1"></a><a class="docs-heading-anchor-permalink" href="#BoxTree" title="Permalink"></a></h2><p>For partitions of <code>X</code> into variably sized boxes, one can use <code>BoxTree</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒫 = BoxTree(X)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `X` not defined</code></pre><p>A <code>BoxTree</code> uses a binary tree structure to store a box partition of the domain.  One can refine a  partition by bisecting all boxes in <code>𝒫</code> along the <span>$i$</span>-th coordinate direction through </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒫 = subdivide!(𝒫, i)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `𝒫` not defined</code></pre><p>&lt;!–The <code>BoxTree</code> created above is equivalent to a 4x2 <code>BoxGrid</code>. One can retrieve this using </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; P3 = BoxGrid(P2)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `P2` not defined</code></pre><p><code>BoxTree</code>s use indices of the type <code>(depth, cartesian_index)</code> where <code>cartesian_index</code> is the equivalent index of a <code>BoxGrid</code> with the same size as a <code>BoxTree</code> subdivided <code>depth</code> times. In other words,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; key_to_box( P, (1, 1) ) == key_to_box( P2, (4, (1, 1)) )</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `P` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; key_to_box( P, (4, 2) ) == key_to_box( P2, (4, (4, 2)) )</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `P` not defined</code></pre><p>–&gt;</p><h2 id="BoxSet"><a class="docs-heading-anchor" href="#BoxSet">BoxSet</a><a id="BoxSet-1"></a><a class="docs-heading-anchor-permalink" href="#BoxSet" title="Permalink"></a></h2><p>A core idea of GAIO.jl is to approximate a subset of the domain <span>$X$</span> via a collection of boxes. To construct a <code>BoxSet</code>, there are two typical options: retrieving all boxes from some partition, or locating a box surrounding a (or some) point(s) in <span>$X$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℬ = cover(𝒫, :)    # set of all boxes from 𝒫</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `𝒫` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = (0.2, 0.4)</code><code class="nohighlight hljs ansi" style="display:block;">(0.2, 0.4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℬ = cover(𝒫, x)    # set of one box containing the point x</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `𝒫` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xs = [ rand(2) for _=1:10 ]</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{Vector{Float64}}:
 [0.25841397266992994, 0.2572405948731129]
 [0.2061084921128168, 0.9815311442964074]
 [0.37971747295834946, 0.03462414314764972]
 [0.5990314210088976, 0.05016446581117007]
 [0.017275090846742502, 0.25370185368797016]
 [0.965114798812755, 0.4309535996093695]
 [0.5236883869373989, 0.5781055907658162]
 [0.08275976393273776, 0.09308458252752616]
 [0.49866421108532266, 0.11380589630947224]
 [0.2359205970234155, 0.004208086765971286]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℬ = cover(𝒫, xs)   # set of boxes containing the points in xs</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `𝒫` not defined</code></pre><p>&lt;!–One can also create a <code>Boxset</code> from an iterable of <code>Box</code>es. This will cover every element of the iterable with boxes from <code>P</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x1 = (0.2, 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">(0.2, 0.1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box1 = point_to_box(P, x1)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `P` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x2 = (0.3, 0.6)</code><code class="nohighlight hljs ansi" style="display:block;">(0.3, 0.6)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box2 = point_to_box(P, x2)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `P` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = cover(P, [box1, box2])</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `P` not defined</code></pre><p>–&gt;</p><p>You can access the boxes or their internal data via iteration</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for box in ℬ
           center, radius = box
           # do something
       end
       
       # get an array of boxes</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `ℬ` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; arr_of_boxes = collect(ℬ)
       
       # get an array of box centers</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `ℬ` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; arr_of_centers = collect(box.center for box in ℬ)
       
       # get an array of box radii</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `ℬ` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; arr_of_radii = collect(box.radius for box in ℬ)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `ℬ` not defined</code></pre><h2 id="BoxMap"><a class="docs-heading-anchor" href="#BoxMap">BoxMap</a><a id="BoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#BoxMap" title="Permalink"></a></h2><p>A box map is a function which maps a <code>BoxSet</code> to a <code>BoxSet</code>. Given a map <span>$f : \mathbb{R}^d\to \mathbb{R}^d$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f((x,y)) = (1-1.4*x^2+y, 0.3*x)   # the Hénon map</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code></pre><p>and some box <code>X</code> as domain, you construct a <code>BoxMap</code> by</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; F = BoxMap(f, X)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `X` not defined</code></pre><p>By default, GAIO.jl will try to adaptively choose sample points in a set to compute the image of the set by approximating the (local) Lipschitz constant of the map <span>$f$</span>. There are many other types of <code>BoxMap</code> discretizations available, see the <a href="../boxmaps/boxmaps_general/">section on BoxMaps</a>. </p><p>We can now map a <code>BoxSet ℬ</code> via the <code>BoxMap F</code> by</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒞 = F(ℬ)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `F` not defined</code></pre><p>where the output <code>𝒞</code> is also a <code>BoxSet</code>.</p><p>For long running computations, you can also display a progress meter</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ProgressMeter</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝒞 = F(ℬ; show_progress = true)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `F` not defined</code></pre><h2 id="TransferOperator"><a class="docs-heading-anchor" href="#TransferOperator">TransferOperator</a><a id="TransferOperator-1"></a><a class="docs-heading-anchor-permalink" href="#TransferOperator" title="Permalink"></a></h2><p>The <em>Perron-Frobenius operator</em> (or <em>transfer operator</em>) [[<a href="../references/#lasotamackey">5</a>]] associated to a map <span>$f$</span> can be approximated using the <code>TransferOperator</code> type.  To construct a (discretized) <code>TransferOperator</code> from a <code>BoxMap</code> <span>$F$</span> on the domain <code>BoxSet</code> <code>ℬ</code>, you type</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = TransferOperator(F, ℬ)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `F` not defined</code></pre><p>Again, a progress meter can be displayed with the additional keyword argument <code>show_progress = true</code>.</p><p>&lt;!–Internally, <code>GAIO.jl</code> will choose some enumeration of the domain and codomain, and use this for indexing the columns and rows, respectively.  You can generate the associated vector of boxes by <code>enumerated_ℬ = collect(T.domain)</code>. To convert the transfer operator to a matrix (cf. [[<a href="../references/#algGAIO">6</a>]]), one can simply call the <code>sparse</code> function from <code>SparseArrays</code> </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SparseArrays
       
       # mat[i, j] ≈ probability( f(x) ∈ enumerated_B[j]  |  x ∈ enumerated_B[i] )</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mat = sparse(T)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><p>–&gt; Formally, <code>T</code> is a linear (in fact, a Markov) operator on the space of steps functions on the box set ℬ.  Of particular interest are often certain eigenvectors. For example, an eigenvector at the eigenvalue 1 is an (approximate) invariant measure, which characterizes the long term behaviour of <span>$f$</span> according to <a href="https://en.wikipedia.org/wiki/Birkhoff%27s_ergodic_theorem">Birkhoff&#39;s ergodic theorem</a>. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; λ, ev = eigs(T)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; μ = ev[1]   # ev is an array of measures, grab the first one</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `ev` not defined</code></pre><p>This can also be done with the adjoint <em>Koopman operator</em> <code>T&#39;</code>. </p><h2 id="BoxMeasure"><a class="docs-heading-anchor" href="#BoxMeasure">BoxMeasure</a><a id="BoxMeasure-1"></a><a class="docs-heading-anchor-permalink" href="#BoxMeasure" title="Permalink"></a></h2><p>The second output of <code>eigs(T)</code> is a vector of (discrete) measures, <code>BoxMeasure</code>s. A <code>BoxMeasure</code>  is absolutely continuous w.r.t. the volume (i.e. Lebesgue) measure and its density is piecewise constant on the boxes of the domain ℬ. One can let <code>T</code> act on a <code>BoxMeasure</code> simply through multiplication</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν = T*μ</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><p>Of course, the same holds for the the Koopman operator as well. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν = T&#39;*μ</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><p>One can evaulate a <code>BoxMeasure</code> on an arbitrary <code>BoxSet</code> ℬ</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; μ(ℬ)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `μ` not defined</code></pre><p>Similarly, one can integrate a function with respect to a BoxMeasure via</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(x -&gt; sin(x[1] + 2x[2]), μ)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `μ` not defined</code></pre><p>Marginal distributions can be accessed using the <code>marginal</code> function</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; marginal(μ; dim=1)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `μ` not defined</code></pre><p>The measures can also be associated with a (Lebesgue) density</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = density(μ)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `μ` not defined</code></pre><p>Since a measure μ is a function defined over measurable sets, composite measures <span>$g \circ \mu$</span> are well-defined for functions <span>$g : \mathbb{R} \to \mathbb{R}$</span> (or <span>$g : \mathbb{C} \to \mathbb{C}$</span>). This is supported in GAIO.jl for <code>BoxMeasures</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; η = exp ∘ μ</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `μ` not defined</code></pre><p>Finite signed measures can be given a vector space structure. This is also supported:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν + μ</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `ν` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2ν - μ/2</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `ν` not defined</code></pre><p>&lt;!–A <code>BoxMeasure</code> is implemented by a dictionary, mapping boxes to weights</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for (box, val) in μ
           println(box, &quot; =&gt; &quot;, val)
       end</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `μ` not defined</code></pre><p>To access this structure oneself one can call</p><pre><code class="nohighlight hljs">P = μ.partition
key_val_pairs = pairs(μ)</code></pre><p>–&gt;</p><h2 id="Graphs-of-Boxes"><a class="docs-heading-anchor" href="#Graphs-of-Boxes">Graphs of Boxes</a><a id="Graphs-of-Boxes-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs-of-Boxes" title="Permalink"></a></h2><p>One can equivalently view the transfer operator as a weighted directed graph. That is, the matrix of a <code>TrensferOperator</code> is the (transposed) weighted adjacency matrix for a graph. This graph can be constructed explicitely using the <code>MetaGraphsNext.jl</code> package </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Graphs, MetaGraphsNext</code><code class="nohighlight hljs ansi" style="display:block;">WARNING: using Graphs.density in module Main conflicts with an existing identifier.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; G = MetaGraph(T)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><p>See also the <a href="https://juliagraphs.org/Graphs.jl/stable/">Graphs</a> and <a href="https://juliagraphs.org/MetaGraphsNext.jl/stable/">MetaGraphsNext</a> documentation. </p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>GAIO.jl offers both <code>Plots</code> or <code>Makie</code> for plotting. To plot a <code>BoxSet</code> or a <code>BoxMeasure</code>, simply choose either Plots or a Makie backend, eg. <code>GLMakie</code>, and call <code>plot</code> on a <code>BoxSet</code> or <code>BoxMeasure</code></p><pre><code class="language-julia hljs">using GLMakie: plot

plot(ℬ)
plot(μ)</code></pre><p>Plotting works with all the functionality of either package. This means you can set box plots as subplots, add colorbars, etc., using the Plots or Makie interface. For an example, see <code>examples/invariant_measure_2d.jl</code>. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting started</a><a class="docs-footer-nextpage" href="../algorithms/limit_sets/">Limit Sets and Attractors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 16 September 2025 11:15">Tuesday 16 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
