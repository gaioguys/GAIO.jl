<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General usage · GAIO.jl</title><meta name="title" content="General usage · GAIO.jl"/><meta property="og:title" content="General usage · GAIO.jl"/><meta property="twitter:title" content="General usage · GAIO.jl"/><meta name="description" content="Documentation for GAIO.jl."/><meta property="og:description" content="Documentation for GAIO.jl."/><meta property="twitter:description" content="Documentation for GAIO.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>General usage</a><ul class="internal"><li><a class="tocitem" href="#BoxGrid"><span>BoxGrid</span></a></li><li><a class="tocitem" href="#BoxTree"><span>BoxTree</span></a></li><li><a class="tocitem" href="#BoxSet"><span>BoxSet</span></a></li><li><a class="tocitem" href="#BoxMap"><span>BoxMap</span></a></li><li><a class="tocitem" href="#Using-BoxMap"><span>Using BoxMap</span></a></li><li><a class="tocitem" href="#TransferOperator"><span>TransferOperator</span></a></li><li><a class="tocitem" href="#BoxMeasure"><span>BoxMeasure</span></a></li><li><a class="tocitem" href="#Graphs-of-Boxes"><span>Graphs of Boxes</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../algorithms/limit_sets/">Limit Sets and Attractors</a></li><li><a class="tocitem" href="../algorithms/recurrent_set/">Reccurent Set</a></li><li><a class="tocitem" href="../algorithms/unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../algorithms/transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../algorithms/almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../algorithms/cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../algorithms/coherent/">Coherent Sets</a></li><li><a class="tocitem" href="../algorithms/seba/">Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../algorithms/box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../algorithms/ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Conley-Morse Theory</span><ul><li><a class="tocitem" href="../algorithms/morse_graph/">Morse Graph</a></li><li><a class="tocitem" href="../algorithms/conley_index/">Conley Index</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../algorithms/root_covering/">Root Covering</a></li><li><a class="tocitem" href="../algorithms/implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li><li><a class="tocitem" href="../metal/">Using the GPU (Metal)</a></li></ul></li><li><a class="tocitem" href="../examples/">Other Examples</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><a class="tocitem" href="../library_reference/">Library Reference</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>General usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>General usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/general.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>The base of the numerical set oriented methods of this framework are <code>BoxSet</code> (the discretization of a set of boxes) and <code>BoxMap</code> (the discretization of a map). Thus, in the following, we will have a closer look at the two and other useful things to know when using GAIO.jl. </p><p>To create a <code>Box</code> given its center point <code>c = (c_1, c_2, ..., c_d)</code> as well as its &quot;radius&quot; in every axis direction <code>r = (r_1, r_2, ..., c_d)</code>, simply type </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using GAIO</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c, r = (0.5, 0.5), (0.5, 0.5)</code><code class="nohighlight hljs ansi" style="display:block;">((0.5, 0.5), (0.5, 0.5))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Q = Box(c, r)</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.5, 0.5]
   radius: [0.5, 0.5]</code></pre><p>This creates a set <span>$Q = [c_1 - r_1, c_1 + r_1), \times \ldots \times [c_d - r_d, c_d + r_d)$</span>. Conversely, one can get back the vectors <code>c</code> and <code>r</code> by calling</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c, r = Q</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.5, 0.5]
   radius: [0.5, 0.5]</code></pre><h2 id="BoxGrid"><a class="docs-heading-anchor" href="#BoxGrid">BoxGrid</a><a id="BoxGrid-1"></a><a class="docs-heading-anchor-permalink" href="#BoxGrid" title="Permalink"></a></h2><p>Most algorithms in GAIO.jl revolve around a partition of the domain <span>$Q$</span> into small boxes. To create an <span>$n_1 \times \ldots \times n_d$</span> - element equidistant grid of boxes, we can pass the tuple <span>$n = (n_1, \ldots, n_d)$</span> into the function <code>BoxGrid</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = (4, 2)</code><code class="nohighlight hljs ansi" style="display:block;">(4, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BoxGrid(Q, n)</code><code class="nohighlight hljs ansi" style="display:block;">4 x 2 - element BoxGrid</code></pre><p><code>BoxGrid</code>s use a cartesian indexing structure to be memory-efficient. These indices are accessed and used through the API:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = (0.2, 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">(0.2, 0.1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; key = point_to_key(P, x)    # x is some point in the domain Q</code><code class="nohighlight hljs ansi" style="display:block;">(1, 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box = key_to_box(P, key)    # cover the point x with a box from P</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.125, 0.25]
   radius: [0.125, 0.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box = point_to_box(P, x)    # performs both above functions</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.125, 0.25]
   radius: [0.125, 0.25]</code></pre><h2 id="BoxTree"><a class="docs-heading-anchor" href="#BoxTree">BoxTree</a><a id="BoxTree-1"></a><a class="docs-heading-anchor-permalink" href="#BoxTree" title="Permalink"></a></h2><p>For partitions of <span>$Q$</span> into variably sized boxes, one can use <code>BoxTree</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; P2 = BoxTree(Q)</code><code class="nohighlight hljs ansi" style="display:block;">BoxTree of depth 1</code></pre><p>A <code>BoxTree</code> uses a binary tree structure to store a partition of the domain. Every Box of a <code>BoxTree</code> can be split using the command </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; subdivide!(P2)</code><code class="nohighlight hljs ansi" style="display:block;">BoxTree of depth 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subdivide!(P2)</code><code class="nohighlight hljs ansi" style="display:block;">BoxTree of depth 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subdivide!(P2)</code><code class="nohighlight hljs ansi" style="display:block;">BoxTree of depth 4</code></pre><p>The axis direction along which to subdivide cycles through with the depth, i.e. subdividing at depth 1 splits along dimension 1, subdividing at depth <code>d+1</code> splits along dimension 1 again. </p><p>The <code>BoxTree</code> created above is equivalent to a 4x2 <code>BoxGrid</code>. One can retrieve this using </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; P3 = BoxGrid(P2)</code><code class="nohighlight hljs ansi" style="display:block;">4 x 2 - element BoxGrid</code></pre><p><code>BoxTree</code>s use indices of the type <code>(depth, cartesian_index)</code> where <code>cartesian_index</code> is the equivalent index of a <code>BoxGrid</code> with the same size as a <code>BoxTree</code> subdivided <code>depth</code> times. In other words,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; key_to_box( P, (1, 1) ) == key_to_box( P2, (4, (1, 1)) )</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; key_to_box( P, (4, 2) ) == key_to_box( P2, (4, (4, 2)) )</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="BoxSet"><a class="docs-heading-anchor" href="#BoxSet">BoxSet</a><a id="BoxSet-1"></a><a class="docs-heading-anchor-permalink" href="#BoxSet" title="Permalink"></a></h2><p>The core idea behind GAIO.jl is to approximate a subset of the domain via a collection of small boxes. To construct <code>BoxSet</code>s, there are two typical options: getting all boxes in the partition, or locating a box surrounding a point <span>$x \in Q$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = cover(P, x)    # one box surrounding the point x</code><code class="nohighlight hljs ansi" style="display:block;">1 - element BoxSet in 4 x 2 - element BoxGrid</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = cover(P, :)    # set of all boxes in P</code><code class="nohighlight hljs ansi" style="display:block;">8 - element BoxSet in 4 x 2 - element BoxGrid</code></pre><p>One can also create a <code>Boxset</code> from an iterable of <code>Box</code>es. This will cover every element of the iterable with boxes from <code>P</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x1 = (0.2, 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">(0.2, 0.1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box1 = point_to_box(P, x1)</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.125, 0.25]
   radius: [0.125, 0.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x2 = (0.3, 0.6)</code><code class="nohighlight hljs ansi" style="display:block;">(0.3, 0.6)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box2 = point_to_box(P, x2)</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.375, 0.75]
   radius: [0.125, 0.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = cover(P, [box1, box2])</code><code class="nohighlight hljs ansi" style="display:block;">2 - element BoxSet in 4 x 2 - element BoxGrid</code></pre><p><code>BoxSet</code> is a meant to be a memory-efficient way of storing boxes. However, should you want to access the boxes or their internal data, this can be done via iteration:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for box in B
           center, radius = box
           # do something
       end
       
       # get an array of boxes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; arr_of_boxes = collect(B)
       
       # get an array of box centers</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Box{2, Float64}}:
 [0.0, 0.25) × [0.0, 0.5)
 [0.25, 0.5) × [0.5, 1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; arr_of_centers = collect(box.center for box in B)
       
       # get an array of box radii</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SVector{2, Float64}}:
 [0.125, 0.25]
 [0.375, 0.75]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; arr_of_radii = collect(box.radius for box in B)
       
       # (memory-efficiently) create a matrix where each center is a column</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SVector{2, Float64}}:
 [0.125, 0.25]
 [0.125, 0.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mat_of_centers = reinterpret(reshape, eltype(arr_of_centers[1]), arr_of_centers)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 reinterpret(reshape, Float64, ::Vector{SVector{2, Float64}}) with eltype Float64:
 0.125  0.375
 0.25   0.75</code></pre><h2 id="BoxMap"><a class="docs-heading-anchor" href="#BoxMap">BoxMap</a><a id="BoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#BoxMap" title="Permalink"></a></h2><p>A BoxMap is a function which maps boxes to boxes. Given a pointmap <code>f : ℝᵈ → ℝᵈ</code> which accepts an <code>SVector</code> from <code>StaticArrays.jl</code> (or just an <code>NTuple</code>) and returns the same, </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(u)   # the Baker transformation
           x, y = u
           if x &lt; 0.5
               (2x, y/2)
           else
               (2x - 1, y/2 + 1/2)
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code></pre><p>initialize the corresponding <code>BoxMap</code> <code>F</code> by</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; F = BoxMap(f, Q)</code><code class="nohighlight hljs ansi" style="display:block;">SampledBoxMap with 2 sample points</code></pre><p>This will generate a <code>BoxMap</code> which attempts to calculate setwise images of <code>f</code>. One can also use a <code>DynamicalSystem</code> from the very good <code>DynamicalSystems.jl</code>: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using DynamicalSystems: DiscreteDynamicalSystem</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StaticArrays</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dynamic_rule(u::Vec, p, t) where Vec = Vec( f(u) ) # DynamicalSystems.jl syntax</code><code class="nohighlight hljs ansi" style="display:block;">dynamic_rule (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u0 = SA_F64[0, 0]   # this is dummy data</code><code class="nohighlight hljs ansi" style="display:block;">2-element SVector{2, Float64} with indices SOneTo(2):
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p0 = SA_F64[0, 0]   # parameters, in case they are needed</code><code class="nohighlight hljs ansi" style="display:block;">2-element SVector{2, Float64} with indices SOneTo(2):
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; system = DiscreteDynamicalSystem(dynamic_rule, u0, p0)</code><code class="nohighlight hljs ansi" style="display:block;">2-dimensional DeterministicIteratedMap
 deterministic: true
 discrete time: true
 in-place:      false
 dynamic rule:  dynamic_rule
 parameters:    [0.0, 0.0]
 time:          0
 state:         [0.0, 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; F̃ = BoxMap(system, Q)</code><code class="nohighlight hljs ansi" style="display:block;">SampledBoxMap with 2 sample points</code></pre><p>The same works for a continuous dynamical system. </p><div class="admonition is-warning" id="Maps-based-on-DynamicalSystems-cannot-run-on-the-GPU!-e9b4101f721f08c5"><header class="admonition-header">Maps based on `DynamicalSystem`s cannot run on the GPU!<a class="admonition-anchor" href="#Maps-based-on-DynamicalSystems-cannot-run-on-the-GPU!-e9b4101f721f08c5" title="Permalink"></a></header><div class="admonition-body"><p>Currently, you must hard-code your systems, and cannot rely on <code>DifferentialEquations</code> or <code>DynamicalSystems</code> for GPU-acceleration. </p></div></div><div class="admonition is-warning" id="Check-your-time-steps!-cc0d626244d35194"><header class="admonition-header">Check your time-steps!<a class="admonition-anchor" href="#Check-your-time-steps!-cc0d626244d35194" title="Permalink"></a></header><div class="admonition-body"><p>GAIO.jl ALWAYS performs integration over <strong>one</strong> time unit for <code>ContinuousDynamicalSystem</code>s! To perform smaller steps, rescale your dynamical system accordingly!</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using DynamicalSystems: ContinuousDynamicalSystem</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using OrdinaryDiffEq</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function lorenz_dudx(u::Vec, p, t, Δt) where Vec
           x,y,z = u
           σ,ρ,β = p
       
           dudx = Vec(( σ*(y-x), ρ*x-y-x*z, x*y-β*z ))
           return Δt * dudx
       end</code><code class="nohighlight hljs ansi" style="display:block;">lorenz_dudx (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Δt = 0.2</code><code class="nohighlight hljs ansi" style="display:block;">0.2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; lorenz(u, p=p0, t=0) = lorenz_dudx(u, p, t, Δt)</code><code class="nohighlight hljs ansi" style="display:block;">lorenz (generic function with 3 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u0 = SA_F64[0, 0, 0]</code><code class="nohighlight hljs ansi" style="display:block;">3-element SVector{3, Float64} with indices SOneTo(3):
 0.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p0 = SA_F64[10, 28, 0.4]</code><code class="nohighlight hljs ansi" style="display:block;">3-element SVector{3, Float64} with indices SOneTo(3):
 10.0
 28.0
  0.4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; diffeq = (alg = RK4(), dt = 1/20, adaptive = false)</code><code class="nohighlight hljs ansi" style="display:block;">(alg = OrdinaryDiffEqLowOrderRK.RK4{typeof(OrdinaryDiffEqCore.trivial_limiter!), typeof(OrdinaryDiffEqCore.trivial_limiter!), Static.False}(OrdinaryDiffEqCore.trivial_limiter!, OrdinaryDiffEqCore.trivial_limiter!, static(false)), dt = 0.05, adaptive = false)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; lorenz_system = ContinuousDynamicalSystem(lorenz, u0, p0; diffeq)</code><code class="nohighlight hljs ansi" style="display:block;">3-dimensional CoupledODEs
 deterministic: true
 discrete time: false
 in-place:      false
 dynamic rule:  lorenz
 ODE solver:    RK4
 ODE kwargs:    (dt = 0.05, adaptive = false)
 parameters:    [10.0, 28.0, 0.4]
 time:          0.0
 state:         [0.0, 0.0, 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Q̄ = Box((0,0,25), (30,30,30))</code><code class="nohighlight hljs ansi" style="display:block;">Box{3, Float64}:
   center: [0.0, 0.0, 25.0]
   radius: [30.0, 30.0, 30.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; F̄ = BoxMap(lorenz_system, Q̄)</code><code class="nohighlight hljs ansi" style="display:block;">SampledBoxMap with 2 sample points</code></pre><p>By default, GAIO.jl will try to adaptively choose test points to compute setwise images by approximating the (local) Lipschitz constant of the map. There are many other types of <code>BoxMap</code> discretizations available, see the section on BoxMaps for more information. </p><h2 id="Using-BoxMap"><a class="docs-heading-anchor" href="#Using-BoxMap">Using BoxMap</a><a id="Using-BoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#Using-BoxMap" title="Permalink"></a></h2><p>Now, one can map a <code>BoxSet</code> via the <code>BoxMap</code> <code>F</code> by simply calling <code>F</code> as a function </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = F(B)</code><code class="nohighlight hljs ansi" style="display:block;">7 - element BoxSet in 4 x 2 - element BoxGrid</code></pre><p>where the output <code>C</code> is also a <code>BoxSet</code>.</p><p>For long running computations, GAIO.jl can also display a progress meter</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ProgressMeter</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = F(B; show_progress = true)</code><code class="nohighlight hljs ansi" style="display:block;">7 - element BoxSet in 4 x 2 - element BoxGrid</code></pre><p>(Adding a progress meter adds a little bit of overhead, so for super short computations like the above it isn&#39;t recommended)</p><h2 id="TransferOperator"><a class="docs-heading-anchor" href="#TransferOperator">TransferOperator</a><a id="TransferOperator-1"></a><a class="docs-heading-anchor-permalink" href="#TransferOperator" title="Permalink"></a></h2><p>The <em>Perron-Frobenius operator</em> (or <em>transfer operator</em>) [<a href="../references/#lasotamackey">5</a>] is discretized in GAIO.jl using the <code>TransferOperator</code> type. To initialize a <code>TransferOperator</code> that acts on a domain <code>BoxSet</code> <code>B</code> and codomain <code>BoxSet</code> <code>C</code> </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = TransferOperator(F, B, C)   # T operates on the domain covered by the box set B</code><code class="nohighlight hljs ansi" style="display:block;">7 x 2 TransferOperator over 4 x 2 - element BoxGrid with 9 stored entries:

⎡⠆⢘⎤
⎣⡀⢰⎦</code></pre><p>Most often (e.g. in eigenvalue calculations), one wants the domain and codomain to be equal </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = cover(P, :)</code><code class="nohighlight hljs ansi" style="display:block;">8 - element BoxSet in 4 x 2 - element BoxGrid</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = TransferOperator(F, B, B)</code><code class="nohighlight hljs ansi" style="display:block;">8 x 8 TransferOperator over 4 x 2 - element BoxGrid with 33 stored entries:

⎡⢻⣧⠩⠥⎤
⎣⢤⣄⢤⣗⎦</code></pre><p>Again, a progress meter can be displayed for long computations</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ProgressMeter</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = TransferOperator(F, B, B; show_progress = true)</code><code class="nohighlight hljs ansi" style="display:block;">8 x 8 TransferOperator over 4 x 2 - element BoxGrid with 33 stored entries:

⎡⢻⣧⠩⠥⎤
⎣⢤⣄⢤⣗⎦</code></pre><p>Internally, <code>GAIO.jl</code> will choose some enumeration of the domain and codomain, and use this for indexing the columns and rows, respectively. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; enumerated_B = collect(T.domain)</code><code class="nohighlight hljs ansi" style="display:block;">8-element Vector{Box{2, Float64}}:
 [0.5, 0.75) × [0.5, 1.0)
 [0.0, 0.25) × [0.5, 1.0)
 [0.5, 0.75) × [0.0, 0.5)
 [0.0, 0.25) × [0.0, 0.5)
 [0.75, 1.0) × [0.5, 1.0)
 [0.75, 1.0) × [0.0, 0.5)
 [0.25, 0.5) × [0.5, 1.0)
 [0.25, 0.5) × [0.0, 0.5)</code></pre><p>To convert the transfer operator to the underlying transfer matrix described in [<a href="../references/#algGAIO">6</a>], one can simply call the <code>sparse</code> function from <code>SparseArrays</code> </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SparseArrays
       
       # mat[i, j] ≈ probability( f(x) ∈ enumerated_B[j]  |  x ∈ enumerated_B[i] )</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mat = sparse(T)</code><code class="nohighlight hljs ansi" style="display:block;">8×8 SparseMatrixCSC{Float64, Int64} with 33 stored entries:
 0.333333  0.166667  0.166667   ⋅        0.5  0.25  0.214286    ⋅
 0.333333  0.166667  0.166667   ⋅         ⋅    ⋅     ⋅          ⋅
  ⋅        0.166667  0.166667  0.333333   ⋅   0.25  0.214286   0.428571
  ⋅        0.166667  0.166667  0.333333   ⋅    ⋅     ⋅          ⋅
  ⋅         ⋅         ⋅         ⋅         ⋅    ⋅    0.214286    ⋅
  ⋅         ⋅         ⋅         ⋅         ⋅    ⋅    0.214286   0.428571
 0.333333  0.166667  0.166667   ⋅        0.5  0.25  0.0714286   ⋅
  ⋅        0.166667  0.166667  0.333333   ⋅   0.25  0.0714286  0.142857</code></pre><p>To find an approximate invariant measure over <code>B</code> use the <code>eigs</code> function from <code>Arpack.jl</code>. All keyword arguments from <code>Arpack.eigs</code> are supported. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # for the Baker trafo, the Lebesgue measure
       # - i.e. the constant-weight measure - is invariant
       λ, ev = eigs(T);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; λ</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ComplexF64}:
   0.9999999999999991 + 0.0im
  0.49999999999999967 + 0.0im
 -0.37896131637649966 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ev</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{BoxMeasure{Box{2, Float64}, Tuple{Int64, Int64}, ComplexF64, BoxGrid{2, Float64, Int64}, OrderedCollections.OrderedDict{Tuple{Int64, Int64}, ComplexF64}}}:
 BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport
 BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport
 BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; μ = ev[1]   # ev is an array of measures, grab the first one</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport</code></pre><p>This can also be done with the adjoint <em>Koopman operator</em> <code>T&#39;</code>. </p><h2 id="BoxMeasure"><a class="docs-heading-anchor" href="#BoxMeasure">BoxMeasure</a><a id="BoxMeasure-1"></a><a class="docs-heading-anchor-permalink" href="#BoxMeasure" title="Permalink"></a></h2><p>The second output of <code>eigs(T)</code> is a discrete measure, a <code>BoxMeasure</code>. This measure is absolutely continuous w.r.t. the volume (i.e. Lebesgue) measure and its density is piecewise constant on the boxes of the domain. One can let <code>T</code> act on a <code>BoxMeasure</code> simply through multiplication</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν = T*μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport</code></pre><p>Of course, the same holds for the the Koopman operator as well. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν = T&#39;μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport</code></pre><p>One can evaulate a <code>BoxMeasure</code> on a <code>BoxSet</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B</code><code class="nohighlight hljs ansi" style="display:block;">8 - element BoxSet in 4 x 2 - element BoxGrid</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; μ(B)</code><code class="nohighlight hljs ansi" style="display:block;">-2.6065137370063387 + 0.0im</code></pre><p>Similarly, one can integrate a function with respect to a BoxMeasure by calling</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(x -&gt; sin(x[1] + 2x[2]), μ)</code><code class="nohighlight hljs ansi" style="display:block;">-2.267631039885399 + 0.0im</code></pre><p>Marginal distributions can be accessed using the <code>marginal</code> function</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; marginal(μ; dim=1)</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 2 - element BoxGrid with 2 boxes in its suport</code></pre><p>The measures can also be associated with a (Lebesgue) density</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = density(μ)</code><code class="nohighlight hljs ansi" style="display:block;">(::GAIO.var&quot;#eval_density#162&quot;{BoxMeasure{Box{2, Float64}, Tuple{Int64, Int64}, ComplexF64, BoxGrid{2, Float64, Int64}, OrderedCollections.OrderedDict{Tuple{Int64, Int64}, ComplexF64}}, BoxGrid{2, Float64, Int64}}) (generic function with 1 method)</code></pre><p>Since a measure <span>$\mu$</span> is a function defined over measurable sets, composite measures <span>$g \circ \mu$</span> are well-defined for functions <span>$g : \mathbb{R} \to \mathbb{R}$</span> (or <span>$g : \mathbb{C} \to \mathbb{C}$</span>). This is supported in GAIO.jl for <code>BoxMeasures</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; η = exp ∘ μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport</code></pre><p>For multiple BoxMeasures, the concatenation operator <code>∘</code> can be applied to each one using julia&#39;s broadcasting functionality</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; real_ev = real .∘ ev</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{BoxMeasure{Box{2, Float64}, Tuple{Int64, Int64}, Float64, BoxGrid{2, Float64, Int64}, OrderedCollections.OrderedDict{Tuple{Int64, Int64}, Float64}}}:
 BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport
 BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport
 BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport</code></pre><p>Similarly, finite signed measures can be given a vector space structure. This is also supported in GAIO.jl</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν + μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2ν - μ/2</code><code class="nohighlight hljs ansi" style="display:block;">BoxMeasure in 4 x 2 - element BoxGrid with 8 boxes in its suport</code></pre><p>A <code>BoxMeasure</code> is implemented by a dictionary, mapping boxes to weights</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for (box, val) in μ
           println(box, &quot; =&gt; &quot;, val)
       end</code><code class="nohighlight hljs ansi" style="display:block;">[0.5, 0.75) × [0.5, 1.0) =&gt; -0.5000388408127828 + 0.0im
[0.0, 0.25) × [0.5, 1.0) =&gt; -0.2996556288694252 + 0.0im
[0.5, 0.75) × [0.0, 0.5) =&gt; -0.49820046272155954 + 0.0im
[0.0, 0.25) × [0.0, 0.5) =&gt; -0.19946402289774617 + 0.0im
[0.75, 1.0) × [0.5, 1.0) =&gt; -0.09375728265239675 + 0.0im
[0.75, 1.0) × [0.0, 0.5) =&gt; -0.23898915185905062 + 0.0im
[0.25, 0.5) × [0.5, 1.0) =&gt; -0.4375339857111852 + 0.0im
[0.25, 0.5) × [0.0, 0.5) =&gt; -0.3388743614821924 + 0.0im</code></pre><p>To access this structure oneself one can call</p><pre><code class="nohighlight hljs">P = μ.partition
key_val_pairs = pairs(μ)</code></pre><h2 id="Graphs-of-Boxes"><a class="docs-heading-anchor" href="#Graphs-of-Boxes">Graphs of Boxes</a><a id="Graphs-of-Boxes-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs-of-Boxes" title="Permalink"></a></h2><p>One could equivalently view the transfer operator as a weighted directed graph. That is, a transfer matrix in GAIO.jl is the (transposed) weighted adjacency matrix for a graph. This graph can be constructed using the <code>MetaGraphsNext.jl</code> package </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Graphs, MetaGraphsNext</code><code class="nohighlight hljs ansi" style="display:block;">WARNING: using Graphs.density in module Main conflicts with an existing identifier.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; G = MetaGraph(T)</code><code class="nohighlight hljs ansi" style="display:block;">Meta graph based on a SimpleDiGraph{Int64} with vertex labels of type Tuple{Int64, Int64}, vertex metadata of type Nothing, edge metadata of type Float64, graph metadata given by 4 x 2 - element BoxGrid, and default weight 1.0</code></pre><p>See also the <a href="https://juliagraphs.org/Graphs.jl/stable/">Graphs</a> and <a href="https://juliagraphs.org/MetaGraphsNext.jl/stable/">MetaGraphsNext</a> documentation. </p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>GAIO.jl offers both <code>Plots</code> or <code>Makie</code> for plotting. To plot a <code>BoxSet</code> or a <code>BoxMeasure</code>, simply choose either Plots or a Makie backend, eg. <code>GLMakie</code>, and call <code>plot</code> on a <code>BoxSet</code> or <code>BoxMeasure</code></p><pre><code class="language-julia hljs">using GLMakie: plot

plot(B)</code></pre><p>Plotting works with all the functionality of either package. This means you can set box plots as subplots, add colorbars, etc., using the Plots or Makie interface. For an example, see <code>examples/invariant_measure_2d.jl</code>. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting started</a><a class="docs-footer-nextpage" href="../algorithms/limit_sets/">Limit Sets and Attractors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 16 September 2025 08:45">Tuesday 16 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
