<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · GAIO.jl</title><meta name="title" content="Library Reference · GAIO.jl"/><meta property="og:title" content="Library Reference · GAIO.jl"/><meta property="twitter:title" content="Library Reference · GAIO.jl"/><meta name="description" content="Documentation for GAIO.jl."/><meta property="og:description" content="Documentation for GAIO.jl."/><meta property="twitter:description" content="Documentation for GAIO.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../algorithms/limit_sets/">Limit Sets and Attractors</a></li><li><a class="tocitem" href="../algorithms/recurrent_set/">Reccurent Set</a></li><li><a class="tocitem" href="../algorithms/unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../algorithms/transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../algorithms/almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../algorithms/cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../algorithms/coherent/">Coherent Sets</a></li><li><a class="tocitem" href="../algorithms/seba/">Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../algorithms/box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../algorithms/ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Conley-Morse Theory</span><ul><li><a class="tocitem" href="../algorithms/morse_graph/">Morse Graph</a></li><li><a class="tocitem" href="../algorithms/conley_index/">Conley Index</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../algorithms/root_covering/">Root Covering</a></li><li><a class="tocitem" href="../algorithms/implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li><li><a class="tocitem" href="../metal/">Using the GPU (Metal)</a></li></ul></li><li><a class="tocitem" href="../examples/">Other Examples</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library Reference</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/library_reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><ul><li><a href="#CUDAExt.GPUSampledBoxMap"><code>CUDAExt.GPUSampledBoxMap</code></a></li><li><a href="#GAIO.Box"><code>GAIO.Box</code></a></li><li><a href="#GAIO.BoxGrid"><code>GAIO.BoxGrid</code></a></li><li><a href="#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}"><code>GAIO.BoxMap</code></a></li><li><a href="#GAIO.BoxMeasure"><code>GAIO.BoxMeasure</code></a></li><li><a href="#GAIO.BoxSet"><code>GAIO.BoxSet</code></a></li><li><a href="#GAIO.BoxTree"><code>GAIO.BoxTree</code></a></li><li><a href="#GAIO.IntervalBoxMap"><code>GAIO.IntervalBoxMap</code></a></li><li><a href="#GAIO.Node"><code>GAIO.Node</code></a></li><li><a href="#GAIO.SampledBoxMap"><code>GAIO.SampledBoxMap</code></a></li><li><a href="#GAIO.TransferOperator"><code>GAIO.TransferOperator</code></a></li><li><a href="#Arpack.eigs-Tuple{TransferOperator, Any}"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a></li><li><a href="#Arpack.svds-Tuple{TransferOperator}"><code>Arpack.svds</code></a></li><li><a href="#Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a></li><li><a href="#Base.:∘-Tuple{Any, BoxMeasure}"><code>Base.:∘</code></a></li><li><a href="#Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxMeasure{B, K, V, P, D}}} where {B, K, V, P, D}"><code>Base.sum</code></a></li><li><a href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a></li><li><a href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a></li><li><a href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a></li><li><a href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.approx_lipschitz</code></a></li><li><a href="#GAIO.armijo_rule"><code>GAIO.armijo_rule</code></a></li><li><a href="#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{BoxLayout{B}, Any}} where {N, T, B&lt;:Box{N, T}}"><code>GAIO.bounded_point_to_key</code></a></li><li><a href="#GAIO.box_dimension-Tuple{Any}"><code>GAIO.box_dimension</code></a></li><li><a href="#GAIO.center-Tuple{Box}"><code>GAIO.center</code></a></li><li><a href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a></li><li><a href="#GAIO.cover"><code>GAIO.cover</code></a></li><li><a href="#GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}"><code>GAIO.cover_manifold</code></a></li><li><a href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:BoxLayout{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a></li><li><a href="#GAIO.density-Tuple{BoxMeasure}"><code>GAIO.density</code></a></li><li><a href="#GAIO.depth-Union{Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}"><code>GAIO.depth</code></a></li><li><a href="#GAIO.expon"><code>GAIO.expon</code></a></li><li><a href="#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}"><code>GAIO.find_at_depth</code></a></li><li><a href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxMeasure{E, K, V, P} where {K, V, P&lt;:BoxLayout{E}}}} where {N, T, E&lt;:Box{N, T}}"><code>GAIO.finite_time_lyapunov_exponents</code></a></li><li><a href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a></li><li><a href="#GAIO.fixqr!-Tuple{Any, Any}"><code>GAIO.fixqr!</code></a></li><li><a href="#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.hidden_keys</code></a></li><li><a href="#GAIO.index_pair-Tuple{BoxMap, BoxSet}"><code>GAIO.index_pair</code></a></li><li><a href="#GAIO.index_quad-Tuple{BoxMap, BoxSet}"><code>GAIO.index_quad</code></a></li><li><a href="#GAIO.index_to_key-Tuple{AbstractArray, Any}"><code>GAIO.index_to_key</code></a></li><li><a href="#GAIO.iterate_until_equal-Tuple{Any, Any}"><code>GAIO.iterate_until_equal</code></a></li><li><a href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxGrid{N, T, I}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a></li><li><a href="#GAIO.key_to_index-Tuple{AbstractArray, Any}"><code>GAIO.key_to_index</code></a></li><li><a href="#GAIO.leaves-Union{Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}"><code>GAIO.leaves</code></a></li><li><a href="#GAIO.linreg-Tuple{Any, Any}"><code>GAIO.linreg</code></a></li><li><a href="#GAIO.marginal-Tuple{BoxSet}"><code>GAIO.marginal</code></a></li><li><a href="#GAIO.marginal-Tuple{BoxGrid}"><code>GAIO.marginal</code></a></li><li><a href="#GAIO.marginal-Tuple{BoxMeasure}"><code>GAIO.marginal</code></a></li><li><a href="#GAIO.maximal_invariant_set-Tuple{Any, BoxSet}"><code>GAIO.maximal_invariant_set</code></a></li><li><a href="#GAIO.morse_adjacencies-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_adjacencies</code></a></li><li><a href="#GAIO.morse_adjacencies_and_tiles-Tuple{BoxMap, BoxSet}"><code>GAIO.morse_adjacencies_and_tiles</code></a></li><li><a href="#GAIO.morse_component_map-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_component_map</code></a></li><li><a href="#GAIO.morse_graph-Tuple{BoxMap, BoxSet}"><code>GAIO.morse_graph</code></a></li><li><a href="#GAIO.morse_map-Tuple{MatrixNetworks.Strong_components_output}"><code>GAIO.morse_map</code></a></li><li><a href="#GAIO.morse_sets-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}"><code>GAIO.morse_sets</code></a></li><li><a href="#GAIO.morse_tiles-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}"><code>GAIO.morse_tiles</code></a></li><li><a href="#GAIO.neighborhood-Tuple{BoxSet}"><code>GAIO.neighborhood</code></a></li><li><a href="#GAIO.nth_iterate_jacobian-NTuple{4, Any}"><code>GAIO.nth_iterate_jacobian</code></a></li><li><a href="#GAIO.point_to_box-Tuple{BoxLayout, Any}"><code>GAIO.point_to_box</code></a></li><li><a href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxGrid{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a></li><li><a href="#GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}"><code>GAIO.preimage</code></a></li><li><a href="#GAIO.radius-Tuple{Box}"><code>GAIO.radius</code></a></li><li><a href="#GAIO.recurrent_set-Tuple{BoxMap, BoxSet}"><code>GAIO.recurrent_set</code></a></li><li><a href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a></li><li><a href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a></li><li><a href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.sample_adaptive</code></a></li><li><a href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U"><code>GAIO.seba</code></a></li><li><a href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxMeasure{B, K, W, Q, D}}"><code>GAIO.seba</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:BoxTree, S}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxGrid{N, T, I}, Any}} where {N, T, I}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}"><code>GAIO.subdivide!</code></a></li><li><a href="#GAIO.symmetric_image-Tuple{BoxMap, BoxSet}"><code>GAIO.symmetric_image</code></a></li><li><a href="#GAIO.tree_search-Union{Tuple{TR}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TR, Any}, Tuple{TR, Any, Any}} where {N, T, I, TR&lt;:(BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.tree_search</code></a></li><li><a href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a></li><li><a href="#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}"><code>GAIO.vertices</code></a></li><li><a href="#GAIO.volume-Tuple{Box}"><code>GAIO.volume</code></a></li><li><a href="#GAIO.α-Tuple{Any, BoxSet}"><code>GAIO.α</code></a></li><li><a href="#GAIO.ω-Tuple{Any, BoxSet}"><code>GAIO.ω</code></a></li><li><a href="#MakieExt.plotboxes-Tuple"><code>MakieExt.plotboxes</code></a></li><li><a href="#GAIO.@common_gpu_code-NTuple{5, Any}"><code>GAIO.@common_gpu_code</code></a></li><li><a href="#GAIO.@save-Tuple{Any, Vararg{Any}}"><code>GAIO.@save</code></a></li></ul><h3 id="Exported-functions"><a class="docs-heading-anchor" href="#Exported-functions">Exported functions</a><a id="Exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.Box" href="#GAIO.Box"><code>GAIO.Box</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Box{N,T}(center, radius)
Box(center, radius)</code></pre><p>A generalized box in dimension <code>N</code> with element type <code>T</code>.  Mathematically, this is a set</p><p class="math-container">\[[center_1 - radius_1,\ center_1 + radius_1) \ \times \ \ldots \ \times \ [center_N - radius_N,\ center_N + radius_N)\]</p><p>Fields:</p><ul><li><code>center</code>:   vector where the box&#39;s center is located</li><li><code>radius</code>:   vector of radii, length of the box in each dimension</li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">:(==), in #, etc ...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/box.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.BoxGrid" href="#GAIO.BoxGrid"><code>GAIO.BoxGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxGrid(domain::Box{N}, dims::NTuple{N,&lt;:Integer} = ntuple(_-&gt;1, N))</code></pre><p>Data structure to grid a domain into a  <code>dims[1] x dims[2] x ... dims[N]</code> equidistant box grid. </p><p>Fields:</p><ul><li><code>domain</code>:         box defining the entire domain</li><li><code>left</code>:           leftmost / bottom edge of the domain</li><li><code>scale</code>:          1 / diameter of each box in the new grid (componentwise)</li><li><code>dims</code>:           tuple, number of boxes in each dimension</li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">:(==), ndims, size, length, keys, keytype #, etc ...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_regular.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}" href="#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}"><code>GAIO.BoxMap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxMap(map, domain) -&gt; SampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>SampledBoxMap</code> defined  on <code>Box</code>es. </p><p>By default uses adaptive test-point sampling.  For GPU-accelerated <code>BoxMap</code>s, uses a grid of test points by default. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmap.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.BoxMeasure" href="#GAIO.BoxMeasure"><code>GAIO.BoxMeasure</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxMeasure(partition, vals)</code></pre><p>Discrete measure with support on <code>partition.domain</code>, and a  density with respect to the volume measure which is piecewise  constant on the boxes of its support.</p><p>Implemented as a dictionary mapping partition keys to weights. </p><p>Constructors:</p><ul><li>BoxMeasure with constant weight 0 of Type <code>T</code> (default Float64) </li></ul><p>supported over a <code>BoxSet</code> <code>B</code>:</p><pre><code class="language-julia hljs">μ = BoxMeasure(B, T)</code></pre><ul><li>BoxMeasure with specified weights per key</li></ul><pre><code class="language-julia hljs">P = B.partition
weights = Dict( key =&gt; 1 for key in keys(B) )
BoxMeasure(P, weights)</code></pre><ul><li>BoxMeasure with vector of weights supportted over a <code>BoxSet</code> <code>B</code>: </li></ul><pre><code class="language-julia hljs">weights = rand(length(B))
μ = BoxMeasure(B, weights)</code></pre><p>(Note that since <code>Boxset</code>s do not have a deterministic iteration  order by default, this may have unintented results. This  constructor should therefore only be used with  <code>BoxSet{&lt;:Any, &lt;:Any, &lt;:OrderedSet}</code> types)</p><p>Fields:</p><ul><li><code>partition</code>: An <code>BoxLayout</code> whose indices are used </li></ul><p>for <code>vals</code></p><ul><li><code>vals</code>: A dictionary whose keys are the box indices from </li></ul><p><code>partition</code>, and whose values are the measure fo the corresponding box. </p><p>Methods implemented:</p><pre><code class="nohighlight hljs">length, sum, iterate, values, isapprox, ∘, LinearAlgebra.norm, LinearAlgebra.normalize!</code></pre><div class="admonition is-info" id="Norms-of-BoxMeasures-94ba36a8d17af1fa"><header class="admonition-header">Norms of BoxMeasures<a class="admonition-anchor" href="#Norms-of-BoxMeasures-94ba36a8d17af1fa" title="Permalink"></a></header><div class="admonition-body"><p>The p-norm of a BoxMeasure is the L^p function norm  of its density (w.r.t. the Lebesgue measure). </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmeasure.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.BoxSet" href="#GAIO.BoxSet"><code>GAIO.BoxSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxSet(partition, indices::AbstractSet)</code></pre><p>Internal data structure to hold boxes within a partition. </p><p>Constructors:</p><ul><li>set of all boxes in partition / box set <code>P</code>:</li></ul><pre><code class="language-julia hljs">B = cover(P, :)    </code></pre><ul><li>cover the point <code>x</code>, or points <code>x = [x_1, x_2, x_3] # etc ...</code> using boxes from <code>P</code></li></ul><pre><code class="language-julia hljs">B = cover(P, x)</code></pre><ul><li>a covering of <code>S</code> using boxes from <code>P</code></li></ul><pre><code class="language-julia hljs">S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc... 
B = cover(P, S)</code></pre><p>Fields:</p><ul><li><code>partition</code>:  the partition that the set is defined over</li><li><code>set</code>:        set of partition-keys corresponding to the boxes in the set</li></ul><p>Most set operations such as </p><pre><code class="language-julia hljs">union, intersect, setdiff, symdiff, issubset, isdisjoint, issetequal, isempty, length, # etc...</code></pre><p>are supported. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxset.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.BoxTree" href="#GAIO.BoxTree"><code>GAIO.BoxTree</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxTree(domain::Box)</code></pre><p>Binary tree structure to partition <code>domain</code> into (variably sized) boxes. </p><p>Fields:</p><ul><li><code>domain</code>: <code>Box</code> denoting the full domain.</li><li><code>nodes</code>:  vector of <code>Node</code>s. Each node holds two indices pointing to            other nodes in the vector, or 0 if the node is a leaf. </li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">copy, keytype, keys, subdivide #, etc...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_tree.jl#L18-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.IntervalBoxMap" href="#GAIO.IntervalBoxMap"><code>GAIO.IntervalBoxMap</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxMap(:interval, map, domain::Box{N}) -&gt; IntervalBoxMap
BoxMap(:interval, map, domain::Box{N}) -&gt; IntervalBoxMap</code></pre><p>Type representing a discretization of a map using  interval arithmetic to construct rigorous outer coverings  of map images. </p><p>Fields:</p><ul><li><code>map</code>:              Map that defines the dynamical system.</li><li><code>domain</code>:           Domain of the map, <code>B</code>.</li></ul><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmap_intervals.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.SampledBoxMap" href="#GAIO.SampledBoxMap"><code>GAIO.SampledBoxMap</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxMap(:sampled, map, domain::Box, domain_points, image_points)</code></pre><p>Type representing a discretization of a map using sample points. </p><p>Fields:</p><ul><li><code>map</code>:              map that defines the dynamical system.</li><li><code>domain</code>:           domain of the map, <code>B</code>.</li><li><code>domain_points</code>:    the spread of test points to be mapped forward in intersection algorithms.                     Must have the signature <code>domain_points(center, radius)</code> and return                      an iterator of points within <code>Box(center, radius)</code>. </li><li><code>image_points</code>:     the spread of test points for comparison in intersection algorithms.                     Must have the signature <code>domain_points(center, radius)</code> and return                      an iterator of points within <code>Box(center, radius)</code>. </li></ul><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmap_sampled.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.TransferOperator" href="#GAIO.TransferOperator"><code>GAIO.TransferOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TransferOperator(map::BoxMap, domain::BoxSet)
TransferOperator(map::BoxMap, domain::BoxSet, codomain::BoxSet)</code></pre><p>Discretization of the Perron-Frobenius operator, or transfer operator.  Implemented as a sparse matrix with indices referring to  two <code>BoxSet</code>s: <code>domain</code> and <code>codomain</code>. </p><p>There exists two constructors:</p><ul><li>only provide a <code>boxmap</code> and a <code>domain</code>. In this case,  the <code>codomain</code> is generated as the image of <code>domain</code> under  the <code>boxmap</code>. <pre><code class="language-julia hljs">julia&gt; P = BoxGrid( Box((0,0), (1,0)), (10,10) )
  10 x 10 - element BoxGrid

julia&gt; domain = BoxSet( P, Set((1,2), (2,3), (3,4)) )
  3 - element Boxset over 10 x 10 - element BoxGrid

julia&gt; T = TransferOperator(boxmap, domain)
  TransferOperator over [...]</code></pre></li><li>provide <code>domain</code> and <code>codomain</code>. In this case,  the size of the transition matrix is given. <pre><code class="language-julia hljs">julia&gt; codomain = domain
  3 - element Boxset over 10 x 10 - element BoxGrid

julia&gt; T = TransferOperator(boxmap, domain, codomain)
  TransferOperator over [...]</code></pre></li></ul><p>Fields:</p><ul><li><code>mat</code>:            <code>SparseMatrixCSC</code> containing transfer weights. The index                    <code>T.mat[i,j]</code> represents the transfer weight FROM the <code>j</code>&#39;th                   box in <code>codomain</code> TO the <code>i</code>&#39;th box in <code>domain</code>. </li><li><code>boxmap</code>:         <code>SampledBoxMap</code> map which dictates the transfer weights. </li><li><code>domain</code>:         <code>BoxSet</code> which contains keys for the already calculated transfers.                    Effectively, these are column pointers, i.e. the                    <code>j</code>th column of <code>T.mat</code> contains transfer weights FROM                    box B<em>j, where B</em>j is the <code>j</code>th box of <code>domain</code>. </li><li><code>codomain</code>:       <code>BoxSet</code> which contains keys for the already calculated transfers.                    Effectively, these are row pointers, i.e. the                    <code>i</code>th row of <code>T.mat</code> contains transfer weights TO                    box B<em>i, where B</em>i is the <code>i</code>th box of <code>codomain</code>. </li></ul><pre><code class="language-julia hljs">        domain --&gt;
codomain  .   .   .   .   .
    |     .   .   .   .   .
    |     .   .   .   .   .
    v     .   .  mat  .   .
          .   .   .   .   .
          .   .   .   .   .
          .   .   .   .   .
          .   .   .   .   .</code></pre><p>It is important to note that <code>TranferOperator</code> is only supported over the  box set <code>domain</code>, but if one lets a <code>TranferOperator</code> act on a <code>BoxMeasure</code>, e.g.  by multiplication, then the <code>domain</code> is extended &quot;on the fly&quot; to  include the support of the <code>BoxMeasure</code>.</p><p>Methods Implemented: </p><pre><code class="language-julia hljs">:(==), size, eltype, getindex, setindex!, SparseArrays.sparse, Arpack.eigs, LinearAlgebra.mul! #, etc ...</code></pre><p>Implementation detail:</p><p>The reader may have noticed that the matrix representation  depends on the order of boxes in <code>support</code>. For this reason  an <code>OrderedSet</code> is used. <code>BoxSet</code>s using regular <code>Set</code>s  will be copied and converted to <code>OrderedSet</code>s. </p><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/transfer_operator.jl#L1-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.eigs-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}, Any}" href="#Arpack.eigs-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/transfer_operator.jl#L164-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.eigs-Tuple{TransferOperator, Any}" href="#Arpack.eigs-Tuple{TransferOperator, Any}"><code>Arpack.eigs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/transfer_operator.jl#L164-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.eigs-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}, Any}" href="#Arpack.eigs-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/transfer_operator.jl#L164-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}" href="#Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxMeasure</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/transfer_operator.jl#L186-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.svds-Tuple{TransferOperator}" href="#Arpack.svds-Tuple{TransferOperator}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxMeasure</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/transfer_operator.jl#L186-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}" href="#Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxMeasure</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/transfer_operator.jl#L186-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxMap(:adaptive, f, domain::Box) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> which uses <code>sample_adaptive</code> to  generate test points as described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmap_sampled.jl#L74-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxMap(:grid, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>n_points</code>, which is  a tuple of length equal to the dimension of the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmap_sampled.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, map, domain::Box{N}; n_points=16*N) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses <code>n_points</code>  Monte-Carlo test points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmap_sampled.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}" href="#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, map, domain, points) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses the iterator <code>points</code> as test points.  <code>points</code> must be an array or iterator of test points within the unit cube  <code>[-1,1]^N</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmap_sampled.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.adaptive_newton_step" href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adaptive_newton_step(g, g_jacobian, x, k=1)</code></pre><p>Return one step of the adaptive Newton algorithm for the point <code>x</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/optimization.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.approx_lipschitz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">approx_lipschitz(f, center::SVector, radius::SVector, accel=nothing) -&gt; Matrix</code></pre><p>Compute an approximation of the Lipschitz matrix,  i.e. the matrix that satisifies </p><p class="math-container">\[| f(x) - f(y) | \leq L | x - y | \quad \forall \, x,y \in \text{Box(center, radius)}\]</p><p>componentwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmap_sampled.jl#L92-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.armijo_rule" href="#GAIO.armijo_rule"><code>GAIO.armijo_rule</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">armijo_rule(g, Dg, x, d, σ=1e-4, ρ=0.8, α₀=0.05, α₁=1.0)</code></pre><p>Find a step size multiplier <span>$\alpha \in (\alpha_0, \alpha_1]$</span>  such that </p><p class="math-container">\[g(x + \alpha d) - g(x) \leq \alpha \sigma \, Dg(x) \cdot d\]</p><p>This is done by initializing <span>$\alpha = 1$</span> and testing the  above condition. If it is not satisfied, scale <span>$\alpha$</span>  by some constant <span>$\rho &lt; 1$</span> (i.e. set  <span>$\alpha = \rho \cdot \alpha$</span>), and test the condition  again. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/optimization.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{BoxLayout{B}, Any}} where {N, T, B&lt;:Box{N, T}}" href="#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{BoxLayout{B}, Any}} where {N, T, B&lt;:Box{N, T}}"><code>GAIO.bounded_point_to_key</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bounded_point_to_key(G::BoxGrid, point)</code></pre><p>Find the cartesian index of the nearest box within a  <code>BoxGrid</code> to a point. Conicides with <code>point_to_key</code>  if the point lies in the grid. Default behavior  is to set <code>NaN = Inf</code> if <code>NaN</code>s are present in <code>point</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_regular.jl#L142-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.box_dimension-Tuple{Any}" href="#GAIO.box_dimension-Tuple{Any}"><code>GAIO.box_dimension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">box_dimension(boxsets) -&gt; D</code></pre><p>For an iterator <code>boxsets</code> of (successively finer)  <code>BoxSet</code>s, compute the box dimension <code>D</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># F is some BoxMap, S is some BoxSet
box_dimension( relative_attractor(F, S, steps=k) for k in 1:20 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/scalar_diagnostics.jl#L103-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.center-Tuple{Any, Any}" href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center(center, radius)</code></pre><p>Return the center of a box as an iterable.  Default function for <code>image_points</code> in <code>SampledBoxMap</code>s. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/box.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.center-Tuple{Box}" href="#GAIO.center-Tuple{Box}"><code>GAIO.center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center(b::Box)</code></pre><p>Return the center of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/box.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.cover" href="#GAIO.cover"><code>GAIO.cover</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><ul><li><code>BoxSet</code> constructors:<ul><li>set of all boxes in partition / box set <code>P</code>:</li></ul><code>julia   B = cover(P, :)</code><ul><li>cover the point <code>x</code>, or points <code>x = [x_1, x_2, x_3] # etc ...</code> using boxes from <code>P</code></li></ul><code>julia   B = cover(P, x)</code>    <ul><li>a covering of <code>S</code> using boxes from <code>P</code></li></ul><code>julia   S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc...    B = cover(P, S)</code></li></ul><p>Return a subset of the partition or box set <code>P</code> based on the second argument. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxset.jl#L64-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}" href="#GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}"><code>GAIO.cover_manifold</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cover_manifold(f, B::BoxSet; steps=12)</code></pre><p>Use interval arithmetic to compute a covering of  an implicitly defined manifold <span>$M$</span> of the form </p><p class="math-container">\[f(M) \equiv 0\]</p><p>for some function <span>$f : \mathbb{R}^N \to \mathbb{R}$</span>. </p><p>The starting BoxSet <code>B</code> should (coarsely) cover  the manifold. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/optimization.jl#L72-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:BoxLayout{Box{N, T}}}} where {N, T}" href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:BoxLayout{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cover_roots(g, Dg, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute a covering of the roots of <code>g</code> within the  partition <code>P</code>. Generally, <code>B</code> should be  a box set containing the whole partition <code>P</code>, ie  <code>B = cover(P, :)</code>, and should contain a root of <code>g</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/optimization.jl#L52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.density-Tuple{BoxMeasure}" href="#GAIO.density-Tuple{BoxMeasure}"><code>GAIO.density</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">density(μ::BoxMeasure) -&gt; Function</code></pre><p>Return the measure <code>μ</code> as a callable density <code>g</code>, i.e.</p><p class="math-container">\[\int f(x) \, d\mu (x) = \int f(x)g(x) \, dx . \]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmeasure.jl#L161-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.depth-Union{Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}" href="#GAIO.depth-Union{Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}"><code>GAIO.depth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">depth(tree::BoxTree)</code></pre><p>Return the depth of the tree structure. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_tree.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}" href="#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}"><code>GAIO.find_at_depth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_at_depth(tree, depth)</code></pre><p>Return all node indices at a specified depth. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_tree.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxMeasure{E, K, V, P} where {K, V, P&lt;:BoxLayout{E}}}} where {N, T, E&lt;:Box{N, T}}" href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxMeasure{E, K, V, P} where {K, V, P&lt;:BoxLayout{E}}}} where {N, T, E&lt;:Box{N, T}}"><code>GAIO.finite_time_lyapunov_exponents</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">finite_time_lyapunov_exponents(f, Df, μ::BoxMeasure; n=8) -&gt; σ</code></pre><p>Compute the Lyapunov exponents using a spatial integration  method [1] based on Birkhoff&#39;s ergodic theorem. Computes </p><p class="math-container">\[\sigma_j = \frac{1}{n} \int \log R_{jj}( Df^n (x) ) \, dμ (x), \quad j = 1, \ldots, d\]</p><p>with respect to an ergodic invariant measure <span>$\mu$</span>. </p><p>[1] Beyn, WJ., Lust, A. A hybrid method for computing  Lyapunov exponents. Numer. Math. 113, 357–375 (2009).  https://doi.org/10.1007/s00211-009-0236-4</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/scalar_diagnostics.jl#L78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}" href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">finite_time_lyapunov_exponents(F::SampledBoxMap, boxset::BoxSet) -&gt; BoxMeasure</code></pre><p>Compute the Finite Time Lyapunov Exponent for  every box in <code>boxset</code>, where <code>F</code> represents a time-<code>T</code>  integration of some continuous dynamical system.  It is assumed that all boxes in <code>boxset</code> have radii  of some fixed order ϵ. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/scalar_diagnostics.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}" href="#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.hidden_keys</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hidden_keys(tree)</code></pre><p>Return all keys within the tree, including  keys not corresponding to leaf nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_tree.jl#L298-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.index_pair-Tuple{BoxMap, BoxSet}" href="#GAIO.index_pair-Tuple{BoxMap, BoxSet}"><code>GAIO.index_pair</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">index_pair(F::BoxMap, N::BoxSet) -&gt; (P₁, P₀)</code></pre><p>Compute an index pair of <code>BoxSet</code>s P₀ ⊆ P₁ ⊆ M where M = N ∪ nbhd(N). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/conley_index.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.index_quad-Tuple{BoxMap, BoxSet}" href="#GAIO.index_quad-Tuple{BoxMap, BoxSet}"><code>GAIO.index_quad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">index_quad(F::BoxMap, N::BoxSet) -&gt; (P₁, P₀, P̄₁, P̄₀)</code></pre><p>Compute a tuple of index pairs such that  <code>F: (P₁, P₀) → (P̄₁, P̄₀)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/conley_index.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.index_to_key-Tuple{AbstractArray, Any}" href="#GAIO.index_to_key-Tuple{AbstractArray, Any}"><code>GAIO.index_to_key</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">index_to_key(iterable, i)</code></pre><p>Return the object held in the <code>i</code>th position of <code>iterable</code>.  Used to enumerate <code>BoxSet</code>s as  <span>$\left\{ B_1, B_2, \ldots, B_n \right\}$</span> in  <code>TransferOperator</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/transfer_operator.jl#L258-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxGrid{N, T, I}, Any}} where {N, T, I}" href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxGrid{N, T, I}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">key_to_box(G::BoxGrid, key)</code></pre><p>Return the box associated with the index  within a <code>BoxGrid</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_regular.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.key_to_index-Tuple{AbstractArray, Any}" href="#GAIO.key_to_index-Tuple{AbstractArray, Any}"><code>GAIO.key_to_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">key_to_index(iterable, key)</code></pre><p>Find the index in <code>1..length(iterable)</code> which holds <code>key</code>,  or return <code>nothing</code>. Used to enumerate <code>BoxSet</code>s as  <span>$\left\{ B_1, B_2, \ldots, B_n \right\}$</span> in  <code>TransferOperator</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/transfer_operator.jl#L242-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.leaves-Union{Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}" href="#GAIO.leaves-Union{Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}"><code>GAIO.leaves</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leaves(tree, initial_node_idx=1)</code></pre><p>Return the node indices of all leaves.  Begins search at <code>initial_node_idx</code>, i.e. only returns node indices of nodes below  <code>initial_node_idx</code> within the tree. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_tree.jl#L253-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.marginal-Tuple{BoxGrid}" href="#GAIO.marginal-Tuple{BoxGrid}"><code>GAIO.marginal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">marginal(G::BoxGrid{N}; dim) -&gt; BoxGrid{N-1}</code></pre><p>Construct the projection of a <code>BoxGrid</code> along an axis given by  its dimension <code>dim</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_regular.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.marginal-Tuple{BoxMeasure}" href="#GAIO.marginal-Tuple{BoxMeasure}"><code>GAIO.marginal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">marginal(μ::BoxMeasure{Box{N}}; dim) -&gt; BoxMeasure{Box{N-1}}</code></pre><p>Compute the marginal distribution of μ along an axis given by its dimension <code>dim</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmeasure.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.marginal-Tuple{BoxSet}" href="#GAIO.marginal-Tuple{BoxSet}"><code>GAIO.marginal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">marginal(B::BoxSet{Box{N}}; dim) -&gt; BoxSet{Box{N-1}}</code></pre><p>Construct the projection of the <code>BoxSet</code> along an axis given by  its dimension <code>dim</code>. This means that all boxes are projected to  dimension N-1. Overlapping boxes are counted only once. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxset.jl#L314-L320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.maximal_invariant_set-Tuple{Any, BoxSet}" href="#GAIO.maximal_invariant_set-Tuple{Any, BoxSet}"><code>GAIO.maximal_invariant_set</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maximal_invariant_set(F::BoxMap, B::BoxSet; subdivision=true, steps=subdivision ? 12 : 64) -&gt; BoxSet</code></pre><p>Compute the maximal invariant set of <code>F</code>  within the set <code>B</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/invariant_sets.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_component_map-Tuple{MatrixNetworks.Strong_components_output, Any}" href="#GAIO.morse_component_map-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_component_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Concatenation of the condensation map and morse map.  See <code>morse_map</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/morse_graph.jl#L64-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_map-Tuple{MatrixNetworks.Strong_components_output}" href="#GAIO.morse_map-Tuple{MatrixNetworks.Strong_components_output}"><code>GAIO.morse_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a <code>Strong_components_output</code> from <code>MatrixNetworks</code> (in particular  the component map), compute a second map on the vertices of the  condensation graph to the vertices of the morse graph. Vertices of the condensation graph which do not correspond to morse sets, get sent to the (arbitrary) vertex index 0.</p><pre><code class="nohighlight hljs"> origninal         condensation        morse
 graph             graph               graph

    * ──────┐
            │
    * ──────┴───────→ * ───────────────→ *

    * ──────────────→ * ───┐     ┌─────→ *
                           │     │
    * ──────────────→ * ───┴─────┼────→  0
                                 │
    * ─────┬────────→ * ─────────┘
           │
    * ─────┤
           │
    * ─────┘

    ⋮ ==============⟹ ⋮ ==============⟹ ⋮
        condensation        morse
        map                 map</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/morse_graph.jl#L15-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_sets-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}" href="#GAIO.morse_sets-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}"><code>GAIO.morse_sets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a <code>BoxMap</code>, a domain <code>BoxSet</code> (together interpreted  as a transfer graph <code>G</code>),  compute the boxes corresponding to the vertices  of the morse graph, return their union as a <code>BoxSet</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/morse_graph.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_tiles-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}" href="#GAIO.morse_tiles-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}"><code>GAIO.morse_tiles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a <code>BoxMap</code>, a domain <code>BoxSet</code> (together interpreted  as a transfer graph <code>G</code>),  compute the boxes corresponding to the vertices  of the morse graph. These vertices are precisely the  chain recurrent components of <code>G</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/morse_graph.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.neighborhood-Tuple{BoxSet}" href="#GAIO.neighborhood-Tuple{BoxSet}"><code>GAIO.neighborhood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neighborhood(B::BoxSet) -&gt; BoxSet
nbhd(B::BoxSet) -&gt; BoxSet</code></pre><p>Return a one-box wide neighborhood of a BoxSet <code>B</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxset.jl#L286-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.nth_iterate_jacobian-NTuple{4, Any}" href="#GAIO.nth_iterate_jacobian-NTuple{4, Any}"><code>GAIO.nth_iterate_jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nth_iterate_jacobian(f, Df, x, n; return_QR=false) -&gt; Z[, R]</code></pre><p>Compute the Jacobian of the <code>n</code>-times iterated function  <code>f ∘ f ∘ ... ∘ f</code> at <code>x</code> using a QR iteration based on [1].  Requires an approximation <code>Df</code> of the jacobian of <code>f</code>, e.g.  <code>Df(x) = ForwardDiff.jacobian(f, x)</code>.  Optionally, return the QR decomposition. </p><p>[1] Dieci, L., Russell, R. D., Van Vleck, E. S.: &quot;On the  Computation of Lyapunov Exponents for Continuous Dynamical  Systems,&quot; submitted to SIAM J. Numer. Ana. (1993).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/scalar_diagnostics.jl#L28-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.point_to_box-Tuple{BoxLayout, Any}" href="#GAIO.point_to_box-Tuple{BoxLayout, Any}"><code>GAIO.point_to_box</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_to_box(P::BoxLayout, point)</code></pre><p>Find the box within a <code>BoxGrid</code> containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_regular.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxGrid{N, T, I}, Any}} where {N, T, I}" href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxGrid{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">point_to_key(G::BoxGrid, point)</code></pre><p>Find the index for the box within a <code>BoxGrid</code>  contatining a point, or <code>nothing</code> if the point does  not lie in the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_regular.jl#L124-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}" href="#GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}"><code>GAIO.preimage</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">preimage(F::BoxMap, B::BoxSet, Q::BoxSet) -&gt; BoxSet</code></pre><p>Compute the (restricted to <code>Q</code>) preimage of <code>B</code> under <code>F</code>, i.e.</p><p class="math-container">\[F^{-1} (B) \cap Q . \]</p><p>Note that the larger <span>$Q$</span> is, the more calculation time required. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/invariant_sets.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.radius-Tuple{Box}" href="#GAIO.radius-Tuple{Box}"><code>GAIO.radius</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radius(b::Box)</code></pre><p>Return the radius of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/box.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.recurrent_set-Tuple{BoxMap, BoxSet}" href="#GAIO.recurrent_set-Tuple{BoxMap, BoxSet}"><code>GAIO.recurrent_set</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">recurrent_set(F::BoxMap, B::BoxSet; subdivision=true, steps=subdivision ? 12 : 64) -&gt; BoxSet</code></pre><p>Compute the (chain) recurrent set within the box set <code>B</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/invariant_sets.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.rescale-Tuple{Any, Any, Any}" href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rescale(center, radius, points)</code></pre><p>Return an iterable which calls <code>rescale(center, radius, point)</code> for each point in <code>points</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/box.jl#L178-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.rescale-Tuple{Any}" href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rescale(points)</code></pre><p>Return a function </p><pre><code class="language-julia hljs">(center, radius) -&gt; rescale(center, radius, points)</code></pre><p>Used in <code>domain_points</code> for <code>BoxMap</code>, <code>PointDiscretizedMap</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/box.jl#L186-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rescale(box, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})
rescale(center, radius, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})</code></pre><p>Scale a <code>point</code> within the unit box <span>$[-1, 1]^N$</span>  to lie within <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/box.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.rk4-Tuple{Any, Any, Any}" href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rk4(f, x, τ)</code></pre><p>Compute one step with step size <code>τ</code> of the classic  fourth order Runge-Kutta method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/maps.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.rk4_flow_map" href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rk4_flow_map(f, x, step_size=0.01, steps=20)</code></pre><p>Perform <code>steps</code> steps of the classic Runge-Kutta fourth order method, with step size <code>step_size</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/maps.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.sample_adaptive</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_adaptive(f, center::SVector, radius::SVector)</code></pre><p>Create a grid of test points using the adaptive technique  described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmap_sampled.jl#L119-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U" href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U"><code>GAIO.seba</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">seba(V::Matrix{&lt;:Real}, Rinit=nothing, maxiter=5000) -&gt; S, R</code></pre><p>Construct a sparse approximation of the basis <code>V</code>, as described in  [1]. Returns matrices <span>$S$</span>, <span>$R$</span> such that</p><p class="math-container">\[\frac{1}{2} \| V - SR \|_F^2 + \mu \| S \|_{1,1}\]</p><p>is minimized, where <span>$\mu \in \mathbb{R}$</span>, <span>$\| \cdot \|_F$</span> is the Frobenuius-norm,  and <span>$\| \cdot \|_{1,1}$</span> is the element sum norm, and <span>$R$</span>  is orthogonal. See [1] for further information on the argument  <code>Rinit</code>, as well as a description of the algorithm. </p><p>[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou.  Sparse eigenbasis approximation: multiple feature extraction  across spatiotemporal scales with application to coherent set  identification. Communications in Nonlinear Science and Numerical  Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/seba.jl#L70-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxMeasure{B, K, W, Q, D}}" href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxMeasure{B, K, W, Q, D}}"><code>GAIO.seba</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">seba(V::Vector{&lt;:BoxMeasure}, Rinit=nothing; which=partition_disjoint, maxiter=5000) -&gt; S, A</code></pre><p>Construct a sparse eigenbasis approximation of <code>V</code>, as described in  [1]. Returns an <code>Array</code> of <code>BoxMeasure</code>s corresponding to the eigenbasis,  as well as a maximum-likelihood <code>BoxMeasure</code> that maps a box to the  element of <code>S</code> which has the largest value over the support. </p><p>The keyword <code>which</code> is used to set the threshholding heuristic,  which is used to extract a partition of the supports from the  sparse basis. Builtin options are</p><pre><code class="language-julia hljs">partition_unity, partition_disjoint, partition_likelihood</code></pre><p>which are all exported functions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/seba.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}" href="#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}"><code>GAIO.subdivide!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subdivide!(tree::BoxTree, key::keytype(tree)) -&gt; BoxTree
subdivide!(tree::BoxTree, depth::Integer) -&gt; BoxTree

subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:BoxTree}, key) -&gt; BoxSet
subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:BoxTree}, depth) -&gt; BoxSet</code></pre><p>Subdivide a <code>BoxTree</code> at <code>key</code>. Dimension along which  the node is subdivided depends on the depth of the node. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_tree.jl#L143-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:BoxTree, S}" href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:BoxTree, S}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subdivide(B::BoxSet{&lt;:Any,&lt;:Any,&lt;:BoxTree}) -&gt; BoxSet</code></pre><p>Bisect every box in <code>boxset</code> along an axis, giving rise to a new  partition of the domain, with double the amount of boxes.  Axis along which to bisect depends on the depth of the nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxset.jl#L267-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxGrid{N, T, I}, Any}} where {N, T, I}" href="#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxGrid{N, T, I}, Any}} where {N, T, I}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subdivide(P::BoxGrid, dim) -&gt; BoxGrid
subdivide(B::BoxSet, dim) -&gt; BoxSet</code></pre><p>Bisect every box in the <code>BoxGrid</code> or <code>BoxSet</code>  along the axis <code>dim</code>, giving rise to a new grid  of the domain, with double the amount of boxes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_regular.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.symmetric_image-Tuple{BoxMap, BoxSet}" href="#GAIO.symmetric_image-Tuple{BoxMap, BoxSet}"><code>GAIO.symmetric_image</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetric_image(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Efficiently compute </p><p class="math-container">\[F (B) \cap B \cap F^{-1} (B) . \]</p><p>Internally performs the following computation  (though more efficiently) </p><pre><code class="language-julia hljs"># create a measure with support over B
μ = BoxMeasure(B)

# compute transfer weights (restricted to B)
T = TransferOperator(F, B, B)

C⁺ = BoxSet(T*μ)    # support of pushforward measure
C⁻ = BoxSet(T&#39;μ)    # support of pullback measure

C = C⁺ ∩ C⁻</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/invariant_sets.jl#L29-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.tree_search-Union{Tuple{TR}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TR, Any}, Tuple{TR, Any, Any}} where {N, T, I, TR&lt;:(BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}" href="#GAIO.tree_search-Union{Tuple{TR}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TR, Any}, Tuple{TR, Any, Any}} where {N, T, I, TR&lt;:(BoxTree{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.tree_search</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tree_search(tree, point, max_depth=Inf) -&gt; key, node_idx</code></pre><p>Find the key and correspoinding node index within the tree  data structure containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_tree.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.unstable_set-Tuple{BoxMap, BoxSet}" href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unstable_set(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Compute the unstable set for a box set <code>B</code>. Generally, <code>B</code> should be  a small box surrounding a fixed point of <code>F</code>. The partition must  be fine enough, since no subdivision occurs in this algorithm. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/invariant_sets.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}" href="#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}"><code>GAIO.vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices(box)</code></pre><p>Return an iterator over the vertices of a <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/box.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.volume-Tuple{Box}" href="#GAIO.volume-Tuple{Box}"><code>GAIO.volume</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">volume(box::Box)</code></pre><p>Compute the volume of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/box.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.α-Tuple{Any, BoxSet}" href="#GAIO.α-Tuple{Any, BoxSet}"><code>GAIO.α</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ω(F::BoxMap, B::BoxSet; subdivision=true, steps=subdivision ? 12 : 64) -&gt; BoxSet</code></pre><p>Compute the α-limit set of <code>B</code> under <code>F</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/invariant_sets.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.ω-Tuple{Any, BoxSet}" href="#GAIO.ω-Tuple{Any, BoxSet}"><code>GAIO.ω</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ω(F::BoxMap, B::BoxSet; subdivision=true, steps=subdivision ? 12 : 64) -&gt; BoxSet</code></pre><p>Compute the ω-limit set of <code>B</code> under <code>F</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/invariant_sets.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.@save-Tuple{Any, Vararg{Any}}" href="#GAIO.@save-Tuple{Any, Vararg{Any}}"><code>GAIO.@save</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@save boxset prefix=&quot;./&quot; suffix=&quot;.boxset&quot; -&gt; filename
@save boxset filename -&gt; filename</code></pre><p>Save a <code>BoxSet</code> as a list of keys. The default file name is the  variable name. </p><p>Note that this does not include information on the  partition of the <code>BoxSet</code>, just the keys. </p><p>.</p><pre><code class="nohighlight hljs">@save boxmap source prefix=&quot;./&quot; suffix=&quot;.boxmap&quot; -&gt; filename
@save boxmap source filename -&gt; filename</code></pre><p>Save a <code>BoxMap</code> as a list of source-keys and their image-keys in the form</p><pre><code class="nohighlight hljs">key_1 -&gt; {image_1, image_2, image_3}
key_2 -&gt; {image_2, image_4, image_8, image_6}
⋮</code></pre><p>.</p><pre><code class="nohighlight hljs">@save transfer_operator prefix=&quot;./&quot; suffix=&quot;.boxmap&quot; -&gt; filename
@save transfer_operator filename -&gt; filename</code></pre><p>Save a <code>TransferOperator</code> as a list of keys and their image-keys in the form</p><pre><code class="nohighlight hljs">key_1 -&gt; {image_1, image_2, image_3}
key_2 -&gt; {image_2, image_4, image_8, image_6}
⋮</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/conley_index.jl#L55-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MakieExt.plotboxes-Tuple" href="#MakieExt.plotboxes-Tuple"><code>MakieExt.plotboxes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(boxset::BoxSet)
plot(boxmeas::BoxMeasure)
plot!(boxset::BoxSet)
plot!(boxmeas::BoxMeasure)</code></pre><p>Plot a <code>BoxSet</code> or <code>BoxMeasure</code>. </p><p><strong>Special Attributes:</strong></p><p><code>projection = x -&gt; x[1:3]</code> If the dimension of the system is larger than 3, use this function to project to 3-d space.</p><p><code>color = :red</code> Color used for the boxes.</p><p><code>colormap = :default</code> Colormap used for plotting <code>BoxMeasure</code>s values.</p><p><code>marker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1))</code> The marker for an individual box. Only works if using Makie for plotting. </p><p>All other attributes are taken from MeshScatter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/ext/MakieExt.jl#L7-L31">source</a></section></article><h3 id="Nonexported-functions"><a class="docs-heading-anchor" href="#Nonexported-functions">Nonexported functions</a><a id="Nonexported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Nonexported-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.Node" href="#GAIO.Node"><code>GAIO.Node</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Node structure used for <code>BoxTree</code>s</p><p>Fields:</p><ul><li><code>left</code> and <code>right</code> refer to indices w.r.t. </li></ul><p><code>trp.nodes</code> for a <code>BoxTree</code> <code>trp</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/partition_tree.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∘-Tuple{Any, BoxMeasure}" href="#Base.:∘-Tuple{Any, BoxMeasure}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∘(f, boxmeas::BoxMeasure) -&gt; BoxMeasure
∘(boxmeas::BoxMeasure, F::BoxMap) -&gt; BoxMeasure</code></pre><p>Postcompose the function <code>f</code> with the <code>boxmeas</code>, or precompose a BoxMap <code>F</code> with the <code>boxmeas</code>  (by applying the Koopman operator). Note that  the support of <code>BoxMeasure</code> must be forward-invariant under <code>F</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmeasure.jl#L202-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxMeasure{B, K, V, P, D}}} where {B, K, V, P, D}" href="#Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxMeasure{B, K, V, P, D}}} where {B, K, V, P, D}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sum(f, μ::BoxMeasure)
sum(f, μ::BoxMeasure, B::BoxSet)
μ(B) = sum(x-&gt;1, μ, B)</code></pre><p>Approximate the value of </p><p class="math-container">\[\int_Q f \, d\mu .\]</p><p>If a BoxSet <code>B</code> is passed as the third argument, then the  integration is restricted to the boxes in <code>B</code></p><p class="math-container">\[\int_{Q \cap \bigcup_{b \in B} b} f \, d\mu .\]</p><p>The notation <code>μ(B)</code> is offered to compute  <span>$\mu (\bigcup_{b \in B} b)$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/boxmeasure.jl#L65-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.expon" href="#GAIO.expon"><code>GAIO.expon</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expon(h, k=1, ϵ=0.2, δ=0.1)</code></pre><p>Return a rough estimate of how many Newton steps  should be taken, given a step size h. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/optimization.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.fixqr!-Tuple{Any, Any}" href="#GAIO.fixqr!-Tuple{Any, Any}"><code>GAIO.fixqr!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fixqr!(Q, R)</code></pre><p>Adjust a QR-decomposition such that the  R-factor has positive diagonal entries. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/scalar_diagnostics.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.iterate_until_equal-Tuple{Any, Any}" href="#GAIO.iterate_until_equal-Tuple{Any, Any}"><code>GAIO.iterate_until_equal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate_until_equal(f, start; max_iterations = Inf)</code></pre><p>Iterate a function <code>f</code> starting at <code>start</code> until  a fixed point is reached or <code>max_iterations</code>  have been performed.  One iteration is always guaranteed! </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/invariant_sets.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.linreg-Tuple{Any, Any}" href="#GAIO.linreg-Tuple{Any, Any}"><code>GAIO.linreg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linreg(xs, ys)</code></pre><p>Simple one-dimensional linear regression used to  approximate box dimension. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/scalar_diagnostics.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_adjacencies-Tuple{MatrixNetworks.Strong_components_output, Any}" href="#GAIO.morse_adjacencies-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_adjacencies</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a <code>strong_components_output</code> from <code>MatrixNetworks</code> (in particular  the component map) as well as the morse map (see <code>morse_map</code>), compute  the adjacency matrix for the morse graph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/morse_graph.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_adjacencies_and_tiles-Tuple{BoxMap, BoxSet}" href="#GAIO.morse_adjacencies_and_tiles-Tuple{BoxMap, BoxSet}"><code>GAIO.morse_adjacencies_and_tiles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a <code>BoxMap</code> and a domain <code>BoxSet</code> (together interpreted  as a transfer graph),  compute the adjacency matrix for the mose graph as well as  the boxes representing the vertices for the morse graph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/algorithms/morse_graph.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.@common_gpu_code-NTuple{5, Any}" href="#GAIO.@common_gpu_code-NTuple{5, Any}"><code>GAIO.@common_gpu_code</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Much of the code for the two gpu extensions is identical.  This macro generates the identical part of the code,  with appropriate object names. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/common_gpu_code.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_graph-Tuple{BoxMap, BoxSet}" href="#GAIO.morse_graph-Tuple{BoxMap, BoxSet}"><code>GAIO.morse_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">morse_graph(F::BoxMap, B::BoxSet) -&gt; MetaGraph</code></pre><p>Construct the morse graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/ext/MetaGraphsNextExt.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDAExt.GPUSampledBoxMap" href="#CUDAExt.GPUSampledBoxMap"><code>CUDAExt.GPUSampledBoxMap</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoxMap(:gpu, map, domain; n_points) -&gt; GPUSampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>GPUSampledBoxMap</code> defined  on <code>Box</code>es. </p><p>Uses the GPU&#39;s acceleration capabilities. </p><p>By default uses a grid of sample points. </p><pre><code class="nohighlight hljs">BoxMap(:montecarlo, :gpu, boxmap_args...)
BoxMap(:grid, :gpu, boxmap_args...)
BoxMap(:pointdiscretized, :gpu, boxmap_args...)
BoxMap(:sampled, :gpu, boxmap_args...)</code></pre><p>Type representing a dicretization of a map using  sample points, which are mapped on the gpu. This  type performs orders of magnitude faster than  standard <code>SampledBoxMap</code>s when point mapping is the  bottleneck. </p><div class="admonition is-warning" id="image_points-with-GPUSampledBoxMap-477a58ac8ee428bf"><header class="admonition-header">`image_points` with `GPUSampledBoxMap`<a class="admonition-anchor" href="#image_points-with-GPUSampledBoxMap-477a58ac8ee428bf" title="Permalink"></a></header><div class="admonition-body"><p><code>GPUSampledBoxMap</code> makes NO use of the <code>image_points</code>  field in <code>SampledBoxMap</code>s. </p></div></div><p>Fields:</p><ul><li><code>map</code>:              map that defines the dynamical system.</li><li><code>domain</code>:           domain of the map, <code>B</code>.</li><li><code>domain_points</code>:    the spread of test points to be mapped forward                      in intersection algorithms.                     WARNING: this differs from                      SampledBoxMap.domain_points in that it is a vector                      of &quot;global&quot; test points within [-1, 1]ᴺ. </li></ul><p>Requires a CUDA-capable gpu. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/35eada9061f1856b06444cd03d143ee982730b8d/src/common_gpu_code.jl#L20-L58">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../boxmaps/new_types/">« Creating you own BoxMap type</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 16 September 2025 08:45">Tuesday 16 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
