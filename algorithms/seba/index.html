<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extracting Multiple Sets via SEBA · GAIO.jl</title><meta name="title" content="Extracting Multiple Sets via SEBA · GAIO.jl"/><meta property="og:title" content="Extracting Multiple Sets via SEBA · GAIO.jl"/><meta property="twitter:title" content="Extracting Multiple Sets via SEBA · GAIO.jl"/><meta name="description" content="Documentation for GAIO.jl."/><meta property="og:description" content="Documentation for GAIO.jl."/><meta property="twitter:description" content="Documentation for GAIO.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GAIO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../general/">General usage</a></li><li><a class="tocitem" href="../../DynamicalSystems/">DynamicalSystems.jl</a></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../limit_sets/">Limit Sets and Attractors</a></li><li><a class="tocitem" href="../recurrent_set/">Reccurent Set</a></li><li><a class="tocitem" href="../unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../coherent/">Coherent Sets</a></li><li class="is-active"><a class="tocitem" href>Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Conley-Morse Theory</span><ul><li><a class="tocitem" href="../morse_graph/">Morse Graph</a></li><li><a class="tocitem" href="../conley_index/">Conley Index</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../root_covering/">Root Covering</a></li><li><a class="tocitem" href="../implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../../cuda/">Using the GPU (Nvidia)</a></li><li><a class="tocitem" href="../../metal/">Using the GPU (Metal)</a></li></ul></li><li><a class="tocitem" href="../../examples/">Other Examples</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><a class="tocitem" href="../../library_reference/">Library Reference</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Transfer- and Koopman Operators</a></li><li class="is-active"><a href>Extracting Multiple Sets via SEBA</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Extracting Multiple Sets via SEBA</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/algorithms/seba.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-Eigenbasis-Approximation-(SEBA)"><a class="docs-heading-anchor" href="#Sparse-Eigenbasis-Approximation-(SEBA)">Sparse Eigenbasis Approximation (SEBA)</a><a id="Sparse-Eigenbasis-Approximation-(SEBA)-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Eigenbasis-Approximation-(SEBA)" title="Permalink"></a></h1><h3 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h3><p>A common use pattern in GAIO.jl is to construct the transfer operator (or related operators), and then investigate the eigenfunctions for some specific structure. This may be e.g. partitioning the state space based on the result of the second leading eigenvector to find almost invariant sets. A common approach is to use <span>$k$</span>-means, though this may not be entirely sufficient. The method of Froyland et. al. [<a href="../../references/#seba">10</a>] attempts to find a sparse basis that approximately spans the one produced by a set of eigenvalues. </p><p>More specifically: denote some eigenvalues <span>$\lambda_1 \geq \ldots \geq \lambda_r$</span> and corresponding eigenvectors <span>$v_1, \ldots, v_r \in \mathbb{R}^d$</span> (typically <span>$r \ll p$</span>) of a data matrix. We write <span>$V = [v_1 \vert \ldots \vert v_r]$</span>. In the context of GAIO.jl this matrix may be the discretized transfer operator. The eigenvectors span a basis <span>$\mathcal{V} \subset \mathbb{R}^p$</span>. We wish to transform this basis into a basis of sparse vectors <span>$s_1, \ldots, s_r \in \mathbb{R}^p$</span> that span a subspace <span>$\mathcal{S} \approx \mathcal{V}$</span>. Mathematically, this can be formulated as solving the optimization problem</p><p class="math-container">\[\underset{S, R}{\mathrm{arg\,min}}\ \frac{1}{2} \| V - S R \|_F^2 + \mu \| S \|_{1,1}\]</p><p>where <span>$S \in \mathbb{R}^{n \times p}$</span> has <span>$\ell_2$</span> norm in each column, <span>$R \in \mathbb{R}^{r \times r}$</span> is orthogonal, and <span>$\mu &gt; 0$</span> is a penalty term. <span>$\| \cdot \|_F$</span> denotes the Frobenius norm and <span>$\| \cdot \|_{1,1}$</span> the element sum norm. </p><p>Solving this problem for <span>$S = [s_1 \vert \ldots \vert s_r]$</span> is done by the SEBA algorithm [1], (which is based on sparse principal component analysis by rotation and truncation - <em>SPCArt</em> [<a href="../../references/#hu2014sparse">11</a>]). At this point, most of the work is finished. Indeed, one may be satisfied with the sparse basis alone. However, recall that the goal is to <em>partition</em> the state space into sets based on the eigenvalues. Hence the final step is to threshhold the sparse vectors to fix which indices are in or out of a feature, that is, find an appropriate <span>$\tau$</span> and set <code>S[S .≤ τ] .= 0</code> such that the least infomation is lost. For this, three heuristics are offered by GAIO.jl:</p><ul><li>Maximum likelihood partition (without threshholding): For each feature (each row) <span>$i$</span>, set <span>$S_{ij} = 0$</span> for all <span>$j$</span> except <span>$j_0 = \underset{j}{\mathrm{arg\,min}}\ S_{ij}$</span>. </li><li>Hard partition: For each feature (each row) <span>$i$</span>, write the values <span>$s_{i1}, \ldots, s_{ir}$</span> of <span>$S_{i\cdot}$</span> in decreasing order. Choose the threshhold <span>$\tau^{dp} = \underset{1 \leq i \leq p}{\mathrm{max}}\ s_{i2}$</span>, i.e. the maximum over the <em>second largest</em> element of each row. Set <code>S[S .≤ τ] .= 0</code>. </li><li>Partition of unity: For each feature (each row) <span>$i$</span>, write the values <span>$s_{i1}, \ldots, s_{ir}$</span> of <span>$S_{i\cdot}$</span> in decreasing order. Choose the threshhold <span>$\tau^{pu} = \underset{1 \leq i \leq p,\  1 \leq j \leq r}{\mathrm{max}} \left\{ s_{ij} \vert \sum_{k=1}^j s_{ik} &gt; 1 \right\}$</span>, i.e. the minimum threshhold such that all rows sum to less than <span>$1$</span>. Set <code>S[S .≤ τ] .= 0</code>. </li></ul><p>Note that the final heuristic does not return a strict partition of the features, but rather a partition of unity. </p><p>By default when calling GAIO.jl&#39;s <code>seba</code>, hard partitioning is performed. </p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>We will continue using the periodically driven double-gyre introduced in the section on <a href="../almost_invariant/#Almost-Invariant-(metastable)-Sets">Almost Invariant (metastable) Sets</a>. See that code block for the definition of the map. </p><pre><code class="language-julia hljs">t₀, τ, steps = 0, 0.1, 20
t₁ = t₀ + τ * steps
Tspan = t₁ - t₀
Φₜ₀ᵗ¹(z) = Φ(z, t₀, τ, steps)

domain = Box((1.0, 0.5), (1.0, 0.5))
P = BoxGrid(domain, (256, 128))
S = cover(P, :)

F = BoxMap(:montecarlo, Φₜ₀ᵗ¹, domain, n_points=32)

T = TransferOperator(F, S, S)

# we give Arpack some help converging to the eigenvalues,
# see the Arpack docs for explanations of keywords
tol, maxiter, v0 = eps()^(1/4), 1000, ones(size(T, 2))
λ, ev = eigs(T; nev=2, which=:LR, maxiter=maxiter, tol=tol, v0=v0)

μ = abs ∘ ev[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BoxMeasure in 256 x 128 - element BoxGrid with 32768 boxes in its suport</code></pre><pre><code class="language-julia hljs">using Plots

p = plot(μ, colormap=:jet);</code></pre><p><img src="../second_eigvec.png" alt="Second egienvector of the transfer operator"/></p><p>We notice there are two &quot;blobs&quot; defining the second eigenmeasure. These correspond to the almost invariant sets; there are two &quot;vortices&quot; where mass flows in a circular pattern and doesn&#39;t mix with the rest of the domain. We wish to isolate these blobs using <code>seba</code></p><pre><code class="language-julia hljs"># seba expects real numbers, ev is complex, so we grab the real components.
# We also potentially have to scale by -1, this depends on what Arpack
# returns so always try both
re_ev = real .∘ (-1 .* ev)

ev_seba, feature_vec = seba(re_ev, which=partition_unity)
μ1, μ2 = ev_seba[1], ev_seba[2]

S1 = BoxSet(P, Set(key for key in keys(μ1) if μ1[key] &gt; 0.01))
S2 = BoxSet(P, Set(key for key in keys(μ2) if μ2[key] &gt; 0.01))


p = plot(S1, xlims=(0,2), ylims=(0,1), color=:red);
p = plot!(p, S2, color=:blue);</code></pre><p><img src="../seba.png" alt="Almost invriant sets isolated by SEBA"/></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.seba-algorithms-seba" href="#GAIO.seba-algorithms-seba"><code>GAIO.seba</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">seba(V::Vector{&lt;:BoxMeasure}, Rinit=nothing; which=partition_disjoint, maxiter=5000) -&gt; S, A</code></pre><p>Construct a sparse eigenbasis approximation of <code>V</code>, as described in  [1]. Returns an <code>Array</code> of <code>BoxMeasure</code>s corresponding to the eigenbasis,  as well as a maximum-likelihood <code>BoxMeasure</code> that maps a box to the  element of <code>S</code> which has the largest value over the support. </p><p>The keyword <code>which</code> is used to set the threshholding heuristic,  which is used to extract a partition of the supports from the  sparse basis. Builtin options are</p><pre><code class="language-julia hljs">partition_unity, partition_disjoint, partition_likelihood</code></pre><p>which are all exported functions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/34aa00e39542ce58bfb10bbc387cacee63755b0f/src/algorithms/seba.jl#L1-L16">source</a></section><section><div><pre><code class="language-julia hljs">seba(V::Matrix{&lt;:Real}, Rinit=nothing, maxiter=5000) -&gt; S, R</code></pre><p>Construct a sparse approximation of the basis <code>V</code>, as described in  [1]. Returns matrices <span>$S$</span>, <span>$R$</span> such that</p><p class="math-container">\[\frac{1}{2} \| V - SR \|_F^2 + \mu \| S \|_{1,1}\]</p><p>is minimized, where <span>$\mu \in \mathbb{R}$</span>, <span>$\| \cdot \|_F$</span> is the Frobenuius-norm,  and <span>$\| \cdot \|_{1,1}$</span> is the element sum norm, and <span>$R$</span>  is orthogonal. See [1] for further information on the argument  <code>Rinit</code>, as well as a description of the algorithm. </p><p>[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou.  Sparse eigenbasis approximation: multiple feature extraction  across spatiotemporal scales with application to coherent set  identification. Communications in Nonlinear Science and Numerical  Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/34aa00e39542ce58bfb10bbc387cacee63755b0f/src/algorithms/seba.jl#L70-L89">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../coherent/">« Coherent Sets</a><a class="docs-footer-nextpage" href="../box_dimension/">Fractal Dimension »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 18 September 2025 11:30">Thursday 18 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
