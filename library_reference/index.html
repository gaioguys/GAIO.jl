<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · GAIO.jl</title><meta name="title" content="Library Reference · GAIO.jl"/><meta property="og:title" content="Library Reference · GAIO.jl"/><meta property="twitter:title" content="Library Reference · GAIO.jl"/><meta name="description" content="Documentation for GAIO.jl."/><meta property="og:description" content="Documentation for GAIO.jl."/><meta property="twitter:description" content="Documentation for GAIO.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_simd/"><code>CPUSampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../algorithms/relative_attractor/">Relative Attractor</a></li><li><a class="tocitem" href="../algorithms/chain_recurrent_set/">Chain Reccurent Set</a></li><li><a class="tocitem" href="../algorithms/maximal_invariant_set/">Maximal Invariant Set</a></li><li><a class="tocitem" href="../algorithms/unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../algorithms/transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../algorithms/almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../algorithms/cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../algorithms/coherent/">Coherent Sets</a></li><li><a class="tocitem" href="../algorithms/seba/">Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../algorithms/box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../algorithms/ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Conley-Morse Theory</span><ul><li><a class="tocitem" href="../algorithms/morse_graph/">Morse Graph</a></li><li><a class="tocitem" href="../algorithms/conley_index/">Conley Index</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../algorithms/root_covering/">Root Covering</a></li><li><a class="tocitem" href="../algorithms/implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../examples/">Other Examples</a></li><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li class="is-active"><a class="tocitem" href>Library Reference</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/library_reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><ul><li><a href="#CUDAExt.GPUSampledBoxMap"><code>CUDAExt.GPUSampledBoxMap</code></a></li><li><a href="#GAIO.Box"><code>GAIO.Box</code></a></li><li><a href="#GAIO.BoxFun"><code>GAIO.BoxFun</code></a></li><li><a href="#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}"><code>GAIO.BoxMap</code></a></li><li><a href="#GAIO.BoxPartition"><code>GAIO.BoxPartition</code></a></li><li><a href="#GAIO.BoxSet"><code>GAIO.BoxSet</code></a></li><li><a href="#GAIO.IntervalBoxMap"><code>GAIO.IntervalBoxMap</code></a></li><li><a href="#GAIO.Node"><code>GAIO.Node</code></a></li><li><a href="#GAIO.SampledBoxMap"><code>GAIO.SampledBoxMap</code></a></li><li><a href="#GAIO.TransferOperator"><code>GAIO.TransferOperator</code></a></li><li><a href="#GAIO.TreePartition"><code>GAIO.TreePartition</code></a></li><li><a href="#SIMDExt.CPUSampledBoxMap"><code>SIMDExt.CPUSampledBoxMap</code></a></li><li><a href="#Arpack.eigs-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs-Tuple{TransferOperator, Any}"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.svds-Tuple{TransferOperator}"><code>Arpack.svds</code></a></li><li><a href="#Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a></li><li><a href="#Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a></li><li><a href="#Base.:∘-Tuple{Any, BoxFun}"><code>Base.:∘</code></a></li><li><a href="#Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}"><code>Base.sum</code></a></li><li><a href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a></li><li><a href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a></li><li><a href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a></li><li><a href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a></li><li><a href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a></li><li><a href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a></li><li><a href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a></li><li><a href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.approx_lipschitz</code></a></li><li><a href="#GAIO.armijo_rule"><code>GAIO.armijo_rule</code></a></li><li><a href="#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}"><code>GAIO.bounded_point_to_key</code></a></li><li><a href="#GAIO.box_dimension-Tuple{Any}"><code>GAIO.box_dimension</code></a></li><li><a href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a></li><li><a href="#GAIO.center-Tuple{Box}"><code>GAIO.center</code></a></li><li><a href="#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.chain_recurrent_set</code></a></li><li><a href="#GAIO.cover"><code>GAIO.cover</code></a></li><li><a href="#GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}"><code>GAIO.cover_manifold</code></a></li><li><a href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a></li><li><a href="#GAIO.density-Tuple{BoxFun}"><code>GAIO.density</code></a></li><li><a href="#GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}"><code>GAIO.depth</code></a></li><li><a href="#GAIO.expon"><code>GAIO.expon</code></a></li><li><a href="#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}"><code>GAIO.find_at_depth</code></a></li><li><a href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a></li><li><a href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P&lt;:AbstractBoxPartition{E}}}} where {N, T, E&lt;:Box{N, T}}"><code>GAIO.finite_time_lyapunov_exponents</code></a></li><li><a href="#GAIO.fixqr!-Tuple{Any, Any}"><code>GAIO.fixqr!</code></a></li><li><a href="#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.hidden_keys</code></a></li><li><a href="#GAIO.index_pair-Tuple{BoxMap, BoxSet}"><code>GAIO.index_pair</code></a></li><li><a href="#GAIO.index_quad-Tuple{BoxMap, BoxSet}"><code>GAIO.index_quad</code></a></li><li><a href="#GAIO.index_to_key-Tuple{AbstractArray, Any}"><code>GAIO.index_to_key</code></a></li><li><a href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a></li><li><a href="#GAIO.key_to_index-Tuple{AbstractArray, Any}"><code>GAIO.key_to_index</code></a></li><li><a href="#GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}"><code>GAIO.leaves</code></a></li><li><a href="#GAIO.linreg-Tuple{Any, Any}"><code>GAIO.linreg</code></a></li><li><a href="#GAIO.marginal-Tuple{BoxPartition}"><code>GAIO.marginal</code></a></li><li><a href="#GAIO.marginal-Tuple{BoxFun}"><code>GAIO.marginal</code></a></li><li><a href="#GAIO.marginal-Tuple{BoxSet}"><code>GAIO.marginal</code></a></li><li><a href="#GAIO.maximal_backward_invariant_set"><code>GAIO.maximal_backward_invariant_set</code></a></li><li><a href="#GAIO.maximal_forward_invariant_set"><code>GAIO.maximal_forward_invariant_set</code></a></li><li><a href="#GAIO.maximal_invariant_set"><code>GAIO.maximal_invariant_set</code></a></li><li><a href="#GAIO.morse_adjacencies-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_adjacencies</code></a></li><li><a href="#GAIO.morse_adjacencies_and_tiles-Tuple{TransferOperator}"><code>GAIO.morse_adjacencies_and_tiles</code></a></li><li><a href="#GAIO.morse_component_map-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_component_map</code></a></li><li><a href="#GAIO.morse_graph-Tuple{TransferOperator}"><code>GAIO.morse_graph</code></a></li><li><a href="#GAIO.morse_map-Tuple{MatrixNetworks.Strong_components_output}"><code>GAIO.morse_map</code></a></li><li><a href="#GAIO.morse_tiles-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}"><code>GAIO.morse_tiles</code></a></li><li><a href="#GAIO.neighborhood-Tuple{BoxSet}"><code>GAIO.neighborhood</code></a></li><li><a href="#GAIO.nth_iterate_jacobian-NTuple{4, Any}"><code>GAIO.nth_iterate_jacobian</code></a></li><li><a href="#GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}"><code>GAIO.point_to_box</code></a></li><li><a href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a></li><li><a href="#GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}"><code>GAIO.preimage</code></a></li><li><a href="#GAIO.preimage-Tuple{BoxMap, BoxSet}"><code>GAIO.preimage</code></a></li><li><a href="#GAIO.radius-Tuple{Box}"><code>GAIO.radius</code></a></li><li><a href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a></li><li><a href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a></li><li><a href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.sample_adaptive</code></a></li><li><a href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxFun{B, K, W, Q, D}}"><code>GAIO.seba</code></a></li><li><a href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U"><code>GAIO.seba</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}"><code>GAIO.subdivide!</code></a></li><li><a href="#GAIO.symmetric_image-Tuple{BoxMap, BoxSet}"><code>GAIO.symmetric_image</code></a></li><li><a href="#GAIO.tree_search-Union{Tuple{TR}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TR, Any}, Tuple{TR, Any, Any}} where {N, T, I, TR&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.tree_search</code></a></li><li><a href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a></li><li><a href="#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}"><code>GAIO.vertices</code></a></li><li><a href="#GAIO.volume-Tuple{Box}"><code>GAIO.volume</code></a></li><li><a href="#MakieExt.plotboxes-Tuple"><code>MakieExt.plotboxes</code></a></li><li><a href="#MakieExt.plotboxes!-Tuple"><code>MakieExt.plotboxes!</code></a></li><li><a href="#GAIO.@save-Tuple{Any, Vararg{Any}}"><code>GAIO.@save</code></a></li></ul><h3 id="Exported-functions"><a class="docs-heading-anchor" href="#Exported-functions">Exported functions</a><a id="Exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.Box" href="#GAIO.Box"><code>GAIO.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Box{N,T}(center, radius)
Box(center, radius)</code></pre><p>A generalized box in dimension <code>N</code> with element type <code>T</code>.  Mathematically, this is a set</p><p class="math-container">\[[center_1 - radius_1,\ center_1 + radius_1) \ \times \ \ldots \ \times \ [center_N - radius_N,\ center_N + radius_N)\]</p><p>Fields:</p><ul><li><code>center</code>:   vector where the box&#39;s center is located</li><li><code>radius</code>:   vector of radii, length of the box in each dimension</li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">:(==), in #, etc ...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/box.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.BoxFun" href="#GAIO.BoxFun"><code>GAIO.BoxFun</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxFun(partition, vals)</code></pre><p>Discretization of a measure over the domain <code>partition.domain</code>, as a piecewise constant function over the boxes of <code>partition</code>. </p><p>Implemented as a sparse vector over the indices of <code>partition</code>. </p><p>Constructors:</p><ul><li>BoxFun with constant weight 1 of Type <code>T</code> (default Float64) </li></ul><p>supported over a <code>BoxSet</code> <code>B</code>:</p><pre><code class="language-julia hljs">μ = BoxFun(B, T)</code></pre><ul><li>BoxFun with specified weights per key</li></ul><pre><code class="language-julia hljs">P = B.partition
weights = Dict( key =&gt; 1 for key in keys(B) )
BoxFun(P, weights)</code></pre><ul><li>BoxFun with vector of weights supportted over a <code>BoxSet</code> <code>B</code>: </li></ul><pre><code class="language-julia hljs">weights = rand(length(B))
μ = BoxFun(B, weights)</code></pre><p>(Note that since <code>Boxset</code>s do not have a deterministic iteration  order by default, this may have unintented results. This  constructor should therefore only be used with  <code>BoxSet{&lt;:Any, &lt;:Any, &lt;:OrderedSet}</code> types)</p><p>Fields:</p><ul><li><code>partition</code>: An <code>AbstractBoxPartition</code> whose indices are used </li></ul><p>for <code>vals</code></p><ul><li><code>vals</code>: A dictionary whose keys are the box indices from </li></ul><p><code>partition</code>, and whose values represent the values of the function. </p><p>Methods implemented:</p><pre><code class="nohighlight hljs">length, sum, iterate, values, isapprox, ∘, LinearAlgebra.norm, LinearAlgebra.normalize!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxfun.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}" href="#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}"><code>GAIO.BoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(map, domain; no_of_points=ntuple(_-&gt;4, N)) -&gt; SampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>SampledBoxMap</code> defined  on <code>Box</code>es. </p><p>By default uses adaptive test-point sampling.  For SIMD- and GPU-accelerated <code>BoxMap</code>s, uses a grid of test points by default. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxmap.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.BoxPartition" href="#GAIO.BoxPartition"><code>GAIO.BoxPartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxPartition(domain::Box{N}, dims::NTuple{N,&lt;:Integer} = ntuple(_-&gt;1, N))</code></pre><p>Data structure to partition a domain into a  <code>dims[1] x dims[2] x ... dims[N]</code> equidistant box grid. </p><p>Fields:</p><ul><li><code>domain</code>:         box defining the entire domain</li><li><code>left</code>:           leftmost / bottom edge of the domain</li><li><code>scale</code>:          1 / diameter of each box in the new partition (componentwise)</li><li><code>dims</code>:           tuple, number of boxes in each dimension</li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">:(==), ndims, size, length, keys, keytype #, etc ...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_regular.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.BoxSet" href="#GAIO.BoxSet"><code>GAIO.BoxSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxSet(partition, indices::AbstractSet)</code></pre><p>Internal data structure to hold boxes within a partition. </p><p>Constructors:</p><ul><li>set of all boxes in partition / box set <code>P</code>:</li></ul><pre><code class="language-julia hljs">B = cover(P, :)    </code></pre><ul><li>cover the point <code>x</code>, or points <code>x = [x_1, x_2, x_3] # etc ...</code> using boxes from <code>P</code></li></ul><pre><code class="language-julia hljs">B = cover(P, x)</code></pre><ul><li>a covering of <code>S</code> using boxes from <code>P</code></li></ul><pre><code class="language-julia hljs">S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc... 
B = cover(P, S)</code></pre><p>Fields:</p><ul><li><code>partition</code>:  the partition that the set is defined over</li><li><code>set</code>:        set of partition-keys corresponding to the boxes in the set</li></ul><p>Most set operations such as </p><pre><code class="language-julia hljs">union, intersect, setdiff, symdiff, issubset, isdisjoint, issetequal, isempty, length, # etc...</code></pre><p>are supported. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxset.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.IntervalBoxMap" href="#GAIO.IntervalBoxMap"><code>GAIO.IntervalBoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:interval, map, domain::Box{N}; n_subintervals::NTuple{N} = ntuple(_-&gt;4, N)) -&gt; IntervalBoxMap
BoxMap(:interval, map, domain::Box{N}; n_subintervals::Function) -&gt; IntervalBoxMap</code></pre><p>Type representing a discretization of a map using  interval arithmetic to construct rigorous outer coverings  of map images. <code>n_subintervals</code> describes how many times  a given box will be subdivided before mapping.  <code>n_subintervals</code> is a Function which  has the signature <code>n_subintervals(center, radius)</code> and  returns a tuple. If a tuple is passed directly for  <code>n_subintervals</code>, then this is converted to a constant Function <code>(_, _) -&gt; n_subintervals</code></p><p>Fields:</p><ul><li><code>map</code>:              Map that defines the dynamical system.</li><li><code>domain</code>:           Domain of the map, <code>B</code>.</li><li><code>n_subintervals</code>:   Function with the signature                      <code>n_subintervals(center, radius)</code> which                      returns a tuple describing how many                      times a box is subdivided in each                      dimension before mapping. </li></ul><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxmap_intervals.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.SampledBoxMap" href="#GAIO.SampledBoxMap"><code>GAIO.SampledBoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:sampled, map, domain::Box, domain_points, image_points)</code></pre><p>Type representing a discretization of a map using sample points. </p><p>Fields:</p><ul><li><code>map</code>:              map that defines the dynamical system.</li><li><code>domain</code>:           domain of the map, <code>B</code>.</li><li><code>domain_points</code>:    the spread of test points to be mapped forward in intersection algorithms.                     Must have the signature <code>domain_points(center, radius)</code> and return                      an iterator of points within <code>Box(center, radius)</code>. </li><li><code>image_points</code>:     the spread of test points for comparison in intersection algorithms.                     Must have the signature <code>domain_points(center, radius)</code> and return                      an iterator of points within <code>Box(center, radius)</code>. </li></ul><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxmap_sampled.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.TransferOperator" href="#GAIO.TransferOperator"><code>GAIO.TransferOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransferOperator(map::BoxMap, domain::BoxSet)
TransferOperator(map::BoxMap, domain::BoxSet, codomain::BoxSet)</code></pre><p>Discretization of the Perron-Frobenius operator, or transfer operator.  Implemented as a sparse matrix with indices referring to  two <code>BoxSet</code>s: <code>domain</code> and <code>codomain</code>. </p><p>There exists two constructors:</p><ul><li>only provide a <code>boxmap</code> and a <code>domain</code>. In this case,  the <code>codomain</code> is generated as the image of <code>domain</code> under  the <code>boxmap</code>. <pre><code class="language-julia hljs">julia&gt; P = BoxPartition( Box((0,0), (1,0)), (10,10) )
  10 x 10 - element BoxPartition

julia&gt; domain = BoxSet( P, Set((1,2), (2,3), (3,4)) )
  3 - element Boxset over 10 x 10 - element BoxPartition

julia&gt; T = TransferOperator(boxmap, domain)
  TransferOperator over [...]</code></pre></li><li>provide <code>domain</code> and <code>codomain</code>. In this case,  the size of the transition matrix is given. <pre><code class="language-julia hljs">julia&gt; codomain = domain
  3 - element Boxset over 10 x 10 - element BoxPartition

julia&gt; T = TransferOperator(boxmap, domain, codomain)
  TransferOperator over [...]</code></pre></li></ul><p>Fields:</p><ul><li><code>mat</code>:            <code>SparseMatrixCSC</code> containing transfer weights. The index                    <code>T.mat[i,j]</code> represents the transfer weight FROM the <code>j</code>&#39;th                   box in <code>codomain</code> TO the <code>i</code>&#39;th box in <code>domain</code>. </li><li><code>boxmap</code>:         <code>SampledBoxMap</code> map which dictates the transfer weights. </li><li><code>domain</code>:         <code>BoxSet</code> which contains keys for the already calculated transfers.                    Effectively, these are column pointers, i.e. the                    <code>j</code>th column of <code>T.mat</code> contains transfer weights FROM                    box B<em>j, where B</em>j is the <code>j</code>th box of <code>domain</code>. </li><li><code>codomain</code>:       <code>BoxSet</code> which contains keys for the already calculated transfers.                    Effectively, these are row pointers, i.e. the                    <code>i</code>th row of <code>T.mat</code> contains transfer weights TO                    box B<em>i, where B</em>i is the <code>i</code>th box of <code>codomain</code>. </li></ul><pre><code class="language-julia hljs">        domain --&gt;
codomain  .   .   .   .   .
    |     .   .   .   .   .
    |     .   .   .   .   .
    v     .   .  mat  .   .
          .   .   .   .   .
          .   .   .   .   .
          .   .   .   .   .
          .   .   .   .   .</code></pre><p>It is important to note that <code>TranferOperator</code> is only supported over the  box set <code>domain</code>, but if one lets a <code>TranferOperator</code> act on a <code>BoxFun</code>, e.g.  by multiplication, then the <code>domain</code> is extended &quot;on the fly&quot; to  include the support of the <code>BoxFun</code>.</p><p>Methods Implemented: </p><pre><code class="language-julia hljs">:(==), size, eltype, getindex, setindex!, SparseArrays.sparse, Arpack.eigs, LinearAlgebra.mul! #, etc ...</code></pre><p>Implementation detail:</p><p>The reader may have noticed that the matrix representation  depends on the order of boxes in <code>support</code>. For this reason  an <code>OrderedSet</code> is used. <code>BoxSet</code>s using regular <code>Set</code>s  will be copied and converted to <code>OrderedSet</code>s. </p><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/transfer_operator.jl#L1-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.TreePartition" href="#GAIO.TreePartition"><code>GAIO.TreePartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreePartition(domain::Box)</code></pre><p>Binary tree structure to partition <code>domain</code> into (variably sized) boxes. </p><p>Fields:</p><ul><li><code>domain</code>: <code>Box</code> denoting the full domain.</li><li><code>nodes</code>:  vector of <code>Node</code>s. Each node holds two indices pointing to            other nodes in the vector, or 0 if the node is a leaf. </li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">copy, keytype, keys, subdivide #, etc...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_tree.jl#L18-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.eigs-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}, Any}" href="#Arpack.eigs-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/transfer_operator.jl#L191-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.eigs-Tuple{TransferOperator, Any}" href="#Arpack.eigs-Tuple{TransferOperator, Any}"><code>Arpack.eigs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/transfer_operator.jl#L191-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.eigs-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}, Any}" href="#Arpack.eigs-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/transfer_operator.jl#L191-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}" href="#Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxFun</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/transfer_operator.jl#L213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.svds-Tuple{TransferOperator}" href="#Arpack.svds-Tuple{TransferOperator}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxFun</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/transfer_operator.jl#L213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}" href="#Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxFun</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/transfer_operator.jl#L213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:adaptive, f, domain::Box) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> which uses <code>sample_adaptive</code> to  generate test points as described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxmap_sampled.jl#L74-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:grid, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>n_points</code>, which is  a tuple of length equal to the dimension of the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxmap_sampled.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, map, domain::Box{N}; n_points=16*N) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses <code>n_points</code>  Monte-Carlo test points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxmap_sampled.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}" href="#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, map, domain, points) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses the iterator <code>points</code> as test points.  <code>points</code> must be an array or iterator of test points within the unit cube  <code>[-1,1]^N</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxmap_sampled.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.adaptive_newton_step" href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adaptive_newton_step(g, g_jacobian, x, k=1)</code></pre><p>Return one step of the adaptive Newton algorithm for the point <code>x</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/optimization.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.approx_lipschitz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approx_lipschitz(f, center::SVector, radius::SVector, accel=nothing) -&gt; Matrix</code></pre><p>Compute an approximation of the Lipschitz matrix,  i.e. the matrix that satisifies </p><p class="math-container">\[| f(x) - f(y) | \leq L | x - y | \quad \forall \, x,y \in \text{Box(center, radius)}\]</p><p>componentwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxmap_sampled.jl#L92-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.armijo_rule" href="#GAIO.armijo_rule"><code>GAIO.armijo_rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">armijo_rule(g, Dg, x, d, σ=1e-4, ρ=0.8, α₀=0.05, α₁=1.0)</code></pre><p>Find a step size multiplier <span>$\alpha \in (\alpha_0, \alpha_1]$</span>  such that </p><p class="math-container">\[g(x + \alpha d) - g(x) \leq \alpha \sigma \, Dg(x) \cdot d\]</p><p>This is done by initializing <span>$\alpha = 1$</span> and testing the  above condition. If it is not satisfied, scale <span>$\alpha$</span>  by some constant <span>$\rho &lt; 1$</span> (i.e. set  <span>$\alpha = \rho \cdot \alpha$</span>), and test the condition  again. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/optimization.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}" href="#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}"><code>GAIO.bounded_point_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bounded_point_to_key(P::BoxPartition, point)</code></pre><p>Find the cartesian index of the nearest box within a  <code>BoxPartition</code> to a point. Conicides with <code>point_to_key</code>  if the point lies in the partition. Default behavior  is to set <code>NaN = Inf</code> if <code>NaN</code>s are present in <code>point</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_regular.jl#L140-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.box_dimension-Tuple{Any}" href="#GAIO.box_dimension-Tuple{Any}"><code>GAIO.box_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box_dimension(boxsets) -&gt; D</code></pre><p>For an iterator <code>boxsets</code> of (successively finer)  <code>BoxSet</code>s, compute the box dimension <code>D</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># F is some BoxMap, S is some BoxSet
box_dimension( relative_attractor(F, S, steps=k) for k in 1:20 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/scalar_diagnostics.jl#L103-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.center-Tuple{Any, Any}" href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(center, radius)</code></pre><p>Return the center of a box as an iterable.  Default function for <code>image_points</code> in <code>SampledBoxMap</code>s. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/box.jl#L175-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.center-Tuple{Box}" href="#GAIO.center-Tuple{Box}"><code>GAIO.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(b::Box)</code></pre><p>Return the center of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/box.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.chain_recurrent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chain_recurrent_set(F::BoxMap, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute the chain recurrent set over the box set <code>B</code>.  <code>B</code> should be a (coarse) covering of the relative attractor,  e.g. <code>B = cover(P, :)</code> for a partition <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/invariant_sets.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.cover" href="#GAIO.cover"><code>GAIO.cover</code></a> — <span class="docstring-category">Function</span></header><section><div><ul><li><code>BoxSet</code> constructors:<ul><li>set of all boxes in partition / box set <code>P</code>:</li></ul><code>julia   B = cover(P, :)</code><ul><li>cover the point <code>x</code>, or points <code>x = [x_1, x_2, x_3] # etc ...</code> using boxes from <code>P</code></li></ul><code>julia   B = cover(P, x)</code>    <ul><li>a covering of <code>S</code> using boxes from <code>P</code></li></ul><code>julia   S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc...    B = cover(P, S)</code></li></ul><p>Return a subset of the partition or box set <code>P</code> based on the second argument. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxset.jl#L64-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}" href="#GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}"><code>GAIO.cover_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_manifold(f, B::BoxSet; steps=12)</code></pre><p>Use interval arithmetic to compute a covering of  an implicitly defined manifold <span>$M$</span> of the form </p><p class="math-container">\[f(M) \equiv 0\]</p><p>for some function <span>$f : \mathbb{R}^N \to \mathbb{R}$</span>. </p><p>The starting BoxSet <code>B</code> should (coarsely) cover  the manifold. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/optimization.jl#L72-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_roots(g, Dg, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute a covering of the roots of <code>g</code> within the  partition <code>P</code>. Generally, <code>B</code> should be  a box set containing the whole partition <code>P</code>, ie  <code>B = cover(P, :)</code>, and should contain a root of <code>g</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/optimization.jl#L52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.density-Tuple{BoxFun}" href="#GAIO.density-Tuple{BoxFun}"><code>GAIO.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density(μ::BoxFun) -&gt; Function</code></pre><p>Return the measure <code>μ</code> as a callable density <code>g</code>, i.e.</p><p class="math-container">\[\int f(x) \, d\mu (x) = \int f(x)g(x) \, dx . \]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxfun.jl#L158-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}" href="#GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}"><code>GAIO.depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">depth(tree::TreePartition)</code></pre><p>Return the depth of the tree structure. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_tree.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}" href="#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}"><code>GAIO.find_at_depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_at_depth(tree, depth)</code></pre><p>Return all node indices at a specified depth. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_tree.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P&lt;:AbstractBoxPartition{E}}}} where {N, T, E&lt;:Box{N, T}}" href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P&lt;:AbstractBoxPartition{E}}}} where {N, T, E&lt;:Box{N, T}}"><code>GAIO.finite_time_lyapunov_exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finite_time_lyapunov_exponents(f, Df, μ::BoxFun; n=8) -&gt; σ</code></pre><p>Compute the Lyapunov exponents using a spatial integration  method [1] based on Birkhoff&#39;s ergodic theorem. Computes </p><p class="math-container">\[\sigma_j = \frac{1}{n} \int \log R_{jj}( Df^n (x) ) \, dμ (x), \quad j = 1, \ldots, d\]</p><p>with respect to an ergodic invariant measure <span>$\mu$</span>. </p><p>[1] Beyn, WJ., Lust, A. A hybrid method for computing  Lyapunov exponents. Numer. Math. 113, 357–375 (2009).  https://doi.org/10.1007/s00211-009-0236-4</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/scalar_diagnostics.jl#L78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}" href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finite_time_lyapunov_exponents(F::SampledBoxMap, boxset::BoxSet) -&gt; BoxFun</code></pre><p>Compute the Finite Time Lyapunov Exponent for  every box in <code>boxset</code>, where <code>F</code> represents a time-<code>T</code>  integration of some continuous dynamical system.  It is assumed that all boxes in <code>boxset</code> have radii  of some fixed order ϵ. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/scalar_diagnostics.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}" href="#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.hidden_keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hidden_keys(tree)</code></pre><p>Return all keys within the tree, including  keys not corresponding to leaf nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_tree.jl#L298-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.index_pair-Tuple{BoxMap, BoxSet}" href="#GAIO.index_pair-Tuple{BoxMap, BoxSet}"><code>GAIO.index_pair</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_pair(F::BoxMap, N::BoxSet) -&gt; (P₁, P₀)</code></pre><p>Compute an index pair of <code>BoxSet</code>s P₀ ⊆ P₁ ⊆ M where M = N ∪ nbhd(N). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/conley_index.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.index_quad-Tuple{BoxMap, BoxSet}" href="#GAIO.index_quad-Tuple{BoxMap, BoxSet}"><code>GAIO.index_quad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_quad(F::BoxMap, N::BoxSet) -&gt; (P₁, P₀, P̄₁, P̄₀)</code></pre><p>Compute a tuple of index pairs such that  <code>F: (P₁, P₀) → (P̄₁, P̄₀)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/conley_index.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.index_to_key-Tuple{AbstractArray, Any}" href="#GAIO.index_to_key-Tuple{AbstractArray, Any}"><code>GAIO.index_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_to_key(iterable, i)</code></pre><p>Return the object held in the <code>i</code>th position of <code>iterable</code>.  Used to enumerate <code>BoxSet</code>s as  <span>$\left\{ B_1, B_2, \ldots, B_n \right\}$</span> in  <code>TransferOperator</code>, <code>BoxGraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/transfer_operator.jl#L285-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">key_to_box(P::BoxPartition, key)</code></pre><p>Return the box associated with the index  within a <code>BoxPartition</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_regular.jl#L105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.key_to_index-Tuple{AbstractArray, Any}" href="#GAIO.key_to_index-Tuple{AbstractArray, Any}"><code>GAIO.key_to_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">key_to_index(iterable, key)</code></pre><p>Find the index in <code>1..length(iterable)</code> which holds <code>key</code>,  or return <code>nothing</code>. Used to enumerate <code>BoxSet</code>s as  <span>$\left\{ B_1, B_2, \ldots, B_n \right\}$</span> in  <code>TransferOperator</code>, <code>BoxGraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/transfer_operator.jl#L269-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}" href="#GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}"><code>GAIO.leaves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leaves(tree, initial_node_idx=1)</code></pre><p>Return the node indices of all leaves.  Begins search at <code>initial_node_idx</code>, i.e. only returns node indices of nodes below  <code>initial_node_idx</code> within the tree. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_tree.jl#L253-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.marginal-Tuple{BoxFun}" href="#GAIO.marginal-Tuple{BoxFun}"><code>GAIO.marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginal(μ::BoxFun{Box{N}}; dim) -&gt; BoxFun{Box{N-1}}</code></pre><p>Compute the marginal distribution of μ along an axis given by its dimension <code>dim</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxfun.jl#L138-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.marginal-Tuple{BoxPartition}" href="#GAIO.marginal-Tuple{BoxPartition}"><code>GAIO.marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginal(P::BoxPartition{N}; dim) -&gt; BoxPartition{N-1}</code></pre><p>Construct the projection of a <code>BoxPartition</code> along an axis given by  its dimension <code>dim</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_regular.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.marginal-Tuple{BoxSet}" href="#GAIO.marginal-Tuple{BoxSet}"><code>GAIO.marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginal(B::BoxSet{Box{N}}; dim) -&gt; BoxSet{Box{N-1}}</code></pre><p>Construct the projection of the <code>BoxSet</code> along an axis given by  its dimension <code>dim</code>. This means that all boxes are projected to  dimension N-1. Overlapping boxes are counted only once. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxset.jl#L312-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.maximal_backward_invariant_set" href="#GAIO.maximal_backward_invariant_set"><code>GAIO.maximal_backward_invariant_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relative_attractor(F::BoxMap, B::BoxSet; steps=12, subdivision=true) -&gt; BoxSet
maximal_backward_invariant_set(F::BoxMap, B::BoxSet; steps=12, subdivision=true) -&gt; BoxSet</code></pre><p>Compute the attractor relative to <code>B</code>. <code>B</code> should be  a (coarse) covering of the relative attractor, e.g.  <code>B = cover(P, :)</code> for a partition <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/invariant_sets.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.maximal_forward_invariant_set" href="#GAIO.maximal_forward_invariant_set"><code>GAIO.maximal_forward_invariant_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maximal_forward_invariant_set(F::BoxMap, B::BoxSet; steps=12, subdivision=true)</code></pre><p>Compute the maximal forward invariant set contained in <code>B</code>.  <code>B</code> should be a (coarse) covering of a forward invariant set,  e.g. <code>B = cover(P, :)</code> for a partition <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/invariant_sets.jl#L115-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.maximal_invariant_set" href="#GAIO.maximal_invariant_set"><code>GAIO.maximal_invariant_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maximal_invariant_set(F::BoxMap, B::BoxSet; steps=12, subdivision=true)</code></pre><p>Compute the maximal invariant set contained in <code>B</code>.  <code>B</code> should be a (coarse) covering of an invariant set,  e.g. <code>B = cover(P, :)</code> for a partition <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/invariant_sets.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_component_map-Tuple{MatrixNetworks.Strong_components_output, Any}" href="#GAIO.morse_component_map-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_component_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Concatenation of the condensation map and morse map.  See <code>morse_map</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/morse_graph.jl#L65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_map-Tuple{MatrixNetworks.Strong_components_output}" href="#GAIO.morse_map-Tuple{MatrixNetworks.Strong_components_output}"><code>GAIO.morse_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a <code>Strong_components_output</code> from <code>MatrixNetworks</code> (in particular  the component map), compute a second map on the vertices of the  condensation graph to the vertices of the morse graph. Vertices of the condensation graph which do not correspond to morse sets, get sent to the (arbitrary) vertex index 0.</p><pre><code class="nohighlight hljs"> origninal         condensation        morse
 graph             graph               graph

    * ──────┐
            │
    * ──────┴───────→ * ───────────────→ *

    * ──────────────→ * ───┐     ┌─────→ *
                           │     │
    * ──────────────→ * ───┴─────┼────→  0
                                 │
    * ─────┬────────→ * ─────────┘
           │
    * ─────┤
           │
    * ─────┘

    ⋮ ==============⟹ ⋮ ==============⟹ ⋮
        condensation        morse
        map                 map</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/morse_graph.jl#L16-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_tiles-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}" href="#GAIO.morse_tiles-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}"><code>GAIO.morse_tiles</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a transfer operator and a morse component map (see  <code>morse_component_map</code>), compute the boxes corresponding to the vertices  of the morse graph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/morse_graph.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.neighborhood-Tuple{BoxSet}" href="#GAIO.neighborhood-Tuple{BoxSet}"><code>GAIO.neighborhood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighborhood(B::BoxSet) -&gt; BoxSet
nbhd(B::BoxSet) -&gt; BoxSet</code></pre><p>Return a one-box wide neighborhood of a BoxSet <code>B</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxset.jl#L284-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.nth_iterate_jacobian-NTuple{4, Any}" href="#GAIO.nth_iterate_jacobian-NTuple{4, Any}"><code>GAIO.nth_iterate_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nth_iterate_jacobian(f, Df, x, n; return_QR=false) -&gt; Z[, R]</code></pre><p>Compute the Jacobian of the <code>n</code>-times iterated function  <code>f ∘ f ∘ ... ∘ f</code> at <code>x</code> using a QR iteration based on [1].  Requires an approximation <code>Df</code> of the jacobian of <code>f</code>, e.g.  <code>Df(x) = ForwardDiff.jacobian(f, x)</code>.  Optionally, return the QR decomposition. </p><p>[1] Dieci, L., Russell, R. D., Van Vleck, E. S.: &quot;On the  Computation of Lyapunov Exponents for Continuous Dynamical  Systems,&quot; submitted to SIAM J. Numer. Ana. (1993).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/scalar_diagnostics.jl#L28-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}" href="#GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}"><code>GAIO.point_to_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_box(P::AbstractBoxPartition, point)</code></pre><p>Find the box within a <code>BoxPartition</code> containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_regular.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_key(P::BoxPartition, point)</code></pre><p>Find the index for the box within a <code>BoxPartition</code>  contatining a point, or <code>nothing</code> if the point does  not lie in the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_regular.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}" href="#GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}"><code>GAIO.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preimage(F::BoxMap, B::BoxSet, Q::BoxSet) -&gt; BoxSet</code></pre><p>Compute the (restricted to <code>Q</code>) preimage of <code>B</code> under <code>F</code>, i.e.</p><p class="math-container">\[F^{-1} (B) \cap Q . \]</p><p>Note that the larger <span>$Q$</span> is, the more calculation time required. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/invariant_sets.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.preimage-Tuple{BoxMap, BoxSet}" href="#GAIO.preimage-Tuple{BoxMap, BoxSet}"><code>GAIO.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preimage(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Efficiently compute </p><p class="math-container">\[F^{-1} (B) \cap B . \]</p><p>Significantly faster than calling <code>preimage(F, B, B)</code>. </p><div class="admonition is-warning"><header class="admonition-header">This is not the entire preimage in the mathematical sense!</header><div class="admonition-body"><p><code>preimage(F, B)</code> computes the RESTRICTED preimage <span>$F^{-1} (B) \cap B$</span>, NOT the full preimage  <span>$F^{-1} (B)$</span>. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/invariant_sets.jl#L53-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.radius-Tuple{Box}" href="#GAIO.radius-Tuple{Box}"><code>GAIO.radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radius(b::Box)</code></pre><p>Return the radius of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/box.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.rescale-Tuple{Any, Any, Any}" href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(center, radius, points)</code></pre><p>Return an iterable which calls <code>rescale(center, radius, point)</code> for each point in <code>points</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/box.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.rescale-Tuple{Any}" href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(points)</code></pre><p>Return a function </p><pre><code class="language-julia hljs">(center, radius) -&gt; rescale(center, radius, points)</code></pre><p>Used in <code>domain_points</code> for <code>BoxMap</code>, <code>PointDiscretizedMap</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/box.jl#L201-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(box, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})
rescale(center, radius, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})</code></pre><p>Scale a <code>point</code> within the unit box <span>$[-1, 1]^N$</span>  to lie within <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/box.jl#L183-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.rk4-Tuple{Any, Any, Any}" href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rk4(f, x, τ)</code></pre><p>Compute one step with step size <code>τ</code> of the classic  fourth order Runge-Kutta method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/maps.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.rk4_flow_map" href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rk4_flow_map(f, x, step_size=0.01, steps=20)</code></pre><p>Perform <code>steps</code> steps of the classic Runge-Kutta fourth order method, with step size <code>step_size</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/maps.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.sample_adaptive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_adaptive(f, center::SVector, radius::SVector)</code></pre><p>Create a grid of test points using the adaptive technique  described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxmap_sampled.jl#L119-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U" href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U"><code>GAIO.seba</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seba(V::Matrix{&lt;:Real}, Rinit=nothing, maxiter=5000) -&gt; S, R</code></pre><p>Construct a sparse approximation of the basis <code>V</code>, as described in  [1]. Returns matrices <span>$S$</span>, <span>$R$</span> such that</p><p class="math-container">\[\frac{1}{2} \| V - SR \|_F^2 + \mu \| S \|_{1,1}\]</p><p>is minimized, where <span>$\mu \in \mathbb{R}$</span>, <span>$\| \cdot \|_F$</span> is the Frobenuius-norm,  and <span>$\| \cdot \|_{1,1}$</span> is the element sum norm, and <span>$R$</span>  is orthogonal. See [1] for further information on the argument  <code>Rinit</code>, as well as a description of the algorithm. </p><p>[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou.  Sparse eigenbasis approximation: multiple feature extraction  across spatiotemporal scales with application to coherent set  identification. Communications in Nonlinear Science and Numerical  Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/seba.jl#L70-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxFun{B, K, W, Q, D}}" href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxFun{B, K, W, Q, D}}"><code>GAIO.seba</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seba(V::Vector{&lt;:BoxFun}, Rinit=nothing; which=partition_disjoint, maxiter=5000) -&gt; S, A</code></pre><p>Construct a sparse eigenbasis approximation of <code>V</code>, as described in  [1]. Returns an <code>Array</code> of <code>BoxFun</code>s corresponding to the eigenbasis,  as well as a maximum-likelihood <code>BoxFun</code> that maps a box to the  element of <code>S</code> which has the largest value over the support. </p><p>The keyword <code>which</code> is used to set the threshholding heuristic,  which is used to extract a partition of the supports from the  sparse basis. Builtin options are</p><pre><code class="language-julia hljs">partition_unity, partition_disjoint, partition_likelihood</code></pre><p>which are all exported functions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/seba.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}" href="#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}"><code>GAIO.subdivide!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide!(tree::TreePartition, key::keytype(tree)) -&gt; TreePartition
subdivide!(tree::TreePartition, depth::Integer) -&gt; TreePartition

subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, key) -&gt; BoxSet
subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, depth) -&gt; BoxSet</code></pre><p>Subdivide a <code>TreePartition</code> at <code>key</code>. Dimension along which  the node is subdivided depends on the depth of the node. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_tree.jl#L143-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}" href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide(B::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}) -&gt; BoxSet</code></pre><p>Bisect every box in <code>boxset</code> along an axis, giving rise to a new  partition of the domain, with double the amount of boxes.  Axis along which to bisect depends on the depth of the nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxset.jl#L265-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide(P::BoxPartition, dim) -&gt; BoxPartition
subdivide(B::BoxSet, dim) -&gt; BoxSet</code></pre><p>Bisect every box in the <code>BoxPartition</code> or <code>BoxSet</code>  along the axis <code>dim</code>, giving rise to a new partition  of the domain, with double the amount of boxes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_regular.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.symmetric_image-Tuple{BoxMap, BoxSet}" href="#GAIO.symmetric_image-Tuple{BoxMap, BoxSet}"><code>GAIO.symmetric_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetric_image(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Efficiently compute </p><p class="math-container">\[F (B) \cap B \cap F^{-1} (B) . \]</p><p>Internally performs the following computation  (though more efficiently) </p><pre><code class="language-julia hljs"># create a measure with support over B
μ = BoxFun(B)

# compute transfer weights (restricted to B)
T = TransferOperator(F, B, B)

C⁺ = BoxSet(T*μ)    # support of pushforward measure
C⁻ = BoxSet(T&#39;μ)    # support of pullback measure

C = C⁺ ∩ C⁻</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/invariant_sets.jl#L73-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.tree_search-Union{Tuple{TR}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TR, Any}, Tuple{TR, Any, Any}} where {N, T, I, TR&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}" href="#GAIO.tree_search-Union{Tuple{TR}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TR, Any}, Tuple{TR, Any, Any}} where {N, T, I, TR&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.tree_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tree_search(tree, point, max_depth=Inf) -&gt; key, node_idx</code></pre><p>Find the key and correspoinding node index within the tree  data structure containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_tree.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.unstable_set-Tuple{BoxMap, BoxSet}" href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unstable_set(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Compute the unstable set for a box set <code>B</code>. Generally, <code>B</code> should be  a small box surrounding a fixed point of <code>F</code>. The partition must  be fine enough, since no subdivision occurs in this algorithm. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/invariant_sets.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}" href="#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}"><code>GAIO.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(box)</code></pre><p>Return an iterator over the vertices of a <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/box.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.volume-Tuple{Box}" href="#GAIO.volume-Tuple{Box}"><code>GAIO.volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volume(box::Box)</code></pre><p>Compute the volume of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/box.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.@save-Tuple{Any, Vararg{Any}}" href="#GAIO.@save-Tuple{Any, Vararg{Any}}"><code>GAIO.@save</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@save boxset prefix=&quot;./&quot; suffix=&quot;.boxset&quot; -&gt; filename
@save boxset filename -&gt; filename</code></pre><p>Save a <code>BoxSet</code> as a list of keys. The default file name is the  variable name. </p><p>Note that this does not include information on the  partition of the <code>BoxSet</code>, just the keys. </p><p>.</p><pre><code class="nohighlight hljs">@save boxmap source prefix=&quot;./&quot; suffix=&quot;.boxmap&quot; -&gt; filename
@save boxmap source filename -&gt; filename</code></pre><p>Save a <code>BoxMap</code> as a list of source-keys and their image-keys in the form</p><pre><code class="nohighlight hljs">key_1 -&gt; {image_1, image_2, image_3}
key_2 -&gt; {image_2, image_4, image_8, image_6}
⋮</code></pre><p>.</p><pre><code class="nohighlight hljs">@save transfer_operator prefix=&quot;./&quot; suffix=&quot;.boxmap&quot; -&gt; filename
@save transfer_operator filename -&gt; filename</code></pre><p>Save a <code>TransferOperator</code> as a list of keys and their image-keys in the form</p><pre><code class="nohighlight hljs">key_1 -&gt; {image_1, image_2, image_3}
key_2 -&gt; {image_2, image_4, image_8, image_6}
⋮</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/conley_index.jl#L55-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MakieExt.plotboxes!-Tuple" href="#MakieExt.plotboxes!-Tuple"><code>MakieExt.plotboxes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(boxset::BoxSet)
plot(boxfun::BoxFun)
plot!(boxset::BoxSet)
plot!(boxfun::BoxFun)</code></pre><p>Plot a <code>BoxSet</code> or <code>BoxFun</code>. </p><p><strong>Special Attributes:</strong></p><p><code>projection = x -&gt; x[1:3]</code> If the dimension of the system is larger than 3, use this function to project to 3-d space.</p><p><code>color = :red</code> Color used for the boxes.</p><p><code>colormap = :default</code> Colormap used for plotting <code>BoxFun</code>s values.</p><p><code>marker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1))</code> The marker for an individual box. Only works if using Makie for plotting. </p><p>All other attributes are taken from MeshScatter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/MakieExt.jl#L7-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MakieExt.plotboxes-Tuple" href="#MakieExt.plotboxes-Tuple"><code>MakieExt.plotboxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(boxset::BoxSet)
plot(boxfun::BoxFun)
plot!(boxset::BoxSet)
plot!(boxfun::BoxFun)</code></pre><p>Plot a <code>BoxSet</code> or <code>BoxFun</code>. </p><p><strong>Special Attributes:</strong></p><p><code>projection = x -&gt; x[1:3]</code> If the dimension of the system is larger than 3, use this function to project to 3-d space.</p><p><code>color = :red</code> Color used for the boxes.</p><p><code>colormap = :default</code> Colormap used for plotting <code>BoxFun</code>s values.</p><p><code>marker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1))</code> The marker for an individual box. Only works if using Makie for plotting. </p><p>All other attributes are taken from MeshScatter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/MakieExt.jl#L7-L31">source</a></section></article><h3 id="Nonexported-functions"><a class="docs-heading-anchor" href="#Nonexported-functions">Nonexported functions</a><a id="Nonexported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Nonexported-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.Node" href="#GAIO.Node"><code>GAIO.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Node structure used for <code>TreePartition</code>s</p><p>Fields:</p><ul><li><code>left</code> and <code>right</code> refer to indices w.r.t. </li></ul><p><code>trp.nodes</code> for a <code>TreePartition</code> <code>trp</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/partition_tree.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∘-Tuple{Any, BoxFun}" href="#Base.:∘-Tuple{Any, BoxFun}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∘(f, boxfun::BoxFun) -&gt; BoxFun
∘(boxfun::BoxFun, F::BoxMap) -&gt; BoxFun</code></pre><p>Postcompose the function <code>f</code> with the <code>boxfun</code>, or precompose a BoxMap <code>F</code> with the <code>boxfun</code>  (by applying the Koopman operator). Note that  the support of <code>BoxFun</code> must be forward-invariant under <code>F</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxfun.jl#L199-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}" href="#Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(f, μ::BoxFun)
sum(f, μ::BoxFun, B::BoxSet)
μ(B) = sum(x-&gt;1, μ, B)</code></pre><p>Integrate a function <code>f</code> with respect to the measure <code>μ</code>, that is, if <code>boxfun</code> is the discretization of a measure <span>$\mu$</span> over the domain  <span>$Q$</span>, then approximate the value of </p><p class="math-container">\[\int_Q f \, d\mu .\]</p><p>If a BoxSet <code>B</code> is passed as the third argument, then the  integration is restricted to the boxes in <code>B</code></p><p class="math-container">\[\int_{Q \cap \bigcup_{b \in B} b} f \, d\mu .\]</p><p>The notation <code>μ(B)</code> is offered to compute  <span>$\mu (\bigcup_{b \in B} b)$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/boxfun.jl#L60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.expon" href="#GAIO.expon"><code>GAIO.expon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expon(h, k=1, ϵ=0.2, δ=0.1)</code></pre><p>Return a rough estimate of how many Newton steps  should be taken, given a step size h. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/optimization.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.fixqr!-Tuple{Any, Any}" href="#GAIO.fixqr!-Tuple{Any, Any}"><code>GAIO.fixqr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fixqr!(Q, R)</code></pre><p>Adjust a QR-decomposition such that the  R-factor has positive diagonal entries. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/scalar_diagnostics.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.linreg-Tuple{Any, Any}" href="#GAIO.linreg-Tuple{Any, Any}"><code>GAIO.linreg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linreg(xs, ys)</code></pre><p>Simple one-dimensional lunear regression used to  approximate box dimension. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/scalar_diagnostics.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_adjacencies-Tuple{MatrixNetworks.Strong_components_output, Any}" href="#GAIO.morse_adjacencies-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_adjacencies</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a <code>strong_components_output</code> from <code>MatrixNetworks</code> (in particular  the component map) as well as the morse map (see <code>morse_map</code>), compute  the adjacency matrix for the morse graph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/morse_graph.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_adjacencies_and_tiles-Tuple{TransferOperator}" href="#GAIO.morse_adjacencies_and_tiles-Tuple{TransferOperator}"><code>GAIO.morse_adjacencies_and_tiles</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a transfer operator (interpreted as a transfer graph),  compute the adjacency matrix for the mose graph as well as  the boxes representing the vertices for the morse graph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/src/algorithms/morse_graph.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.morse_graph-Tuple{TransferOperator}" href="#GAIO.morse_graph-Tuple{TransferOperator}"><code>GAIO.morse_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">morse_graph(F::BoxMap, B::BoxSet) -&gt; MetaGraph
morse_graph(F♯::TransferOperator) -&gt; MetaGraph</code></pre><p>Construct the morse graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/MetaGraphsNextExt.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIMDExt.CPUSampledBoxMap" href="#SIMDExt.CPUSampledBoxMap"><code>SIMDExt.CPUSampledBoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:cpu, map, domain; n_points) -&gt; CPUSampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>CPUSampledBoxMap</code> defined  on <code>Box</code>es. </p><p>Uses the CPU&#39;s SIMD acceleration capabilities. </p><p>By default uses a grid of sample points. </p><pre><code class="nohighlight hljs">BoxMap(:sampled, :cpu, boxmap, idx_base)</code></pre><p>Type representing a discretization of a map using  sample points which are explicitly vectorized. This  type performs roughly 2x as many floating point  operations per second as standard <code>SampledBoxMap</code>s. </p><p>Fields:</p><ul><li><code>boxmap</code>:         <code>SampledBoxMap</code> with one restriction:                   <code>boxmap.domain_points(c, r)</code> must                    return an iterable with eltype                    <code>SVector{N, SIMD.Vec{S,T}}</code> where <code>N</code>                   is the dimension, <code>S</code> is the cpu&#39;s                    SIMD operation capacity, e.g. <code>4</code>,                    and <code>T</code> is the individual element type,                    e.g. <code>Float64</code>. </li><li><code>idx_base</code>:       <code>SIMD.Vec{S,Int}</code> which is used to                    transform a                    <code>Vector{SVector{N, SIMD.Vec{S,T}}}</code>                   into a                    <code>Vector{SVector{N,T}}</code>. </li></ul><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/SIMDExt.jl#L11-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}}} where {N, T}" href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:grid, :simd, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; CPUSampledBoxMap</code></pre><p>Construct a <code>CPUSampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>n_points</code>, which is  a tuple of length equal to the dimension of the domain.  The number of points is rounded up to the nearest mutiple  of the cpu&#39;s SIMD capacity. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/SIMDExt.jl#L88-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}}} where {N, T}" href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, :simd, map, domain::Box{N}; n_points=16*N) -&gt; SampledBoxMap</code></pre><p>Construct a <code>CPUSampledBoxMap</code> that uses <code>n_points</code>  Monte-Carlo test points. The number of points is rounded  up to the nearest multiple of the cpu&#39;s SIMD capacity. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/SIMDExt.jl#L112-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}, Any}} where {N, T}" href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, :simd, map, domain, points) -&gt; CPUSampledBoxMap</code></pre><p>Construct a <code>CPUSampledBoxMap</code> that uses the iterator  <code>points</code> as test points. <code>points</code> must have eltype  <code>SVector{N, SIMD.Vec{S,T}}</code> and be within the unit  cube <code>[-1,1]^N</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/SIMDExt.jl#L64-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CUDAExt.GPUSampledBoxMap" href="#CUDAExt.GPUSampledBoxMap"><code>CUDAExt.GPUSampledBoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:gpu, map, domain; n_points) -&gt; GPUSampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>GPUSampledBoxMap</code> defined  on <code>Box</code>es. </p><p>Uses the GPU&#39;s acceleration capabilities. </p><p>By default uses a grid of sample points. </p><pre><code class="nohighlight hljs">BoxMap(:sampled, :gpu, boxmap)</code></pre><p>Type representing a dicretization of a map using  sample points, which are mapped on the gpu. This  type performs orders of magnitude faster than  standard <code>SampledBoxMap</code>s. </p><div class="admonition is-warning"><header class="admonition-header">`image_points` with `GPUSampledBoxMap`</header><div class="admonition-body"><p><code>GPUSampledBoxMap</code> makes NO use of the <code>image_points</code>  field in <code>SampledBoxMap</code>s. </p></div></div><p>Fields:</p><ul><li><code>boxmap</code>:     <code>SampledBoxMap</code> with one restriction:                <code>boxmap.image_points</code> will not be used. </li></ul><p>Requires a CUDA-capable gpu. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/CUDAExt.jl#L22-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}" href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:grid, :gpu, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; GPUSampledBoxMap</code></pre><p>Construct a <code>GPUSampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>n_points</code>, which is  a tuple of length equal to the dimension of the domain. </p><p>Requires a CUDA-capable gpu. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/CUDAExt.jl#L220-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}" href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, :gpu, map, domain::Box{N}; n_points=16*N) -&gt; GPUSampledBoxMap</code></pre><p>Construct a <code>GPUSampledBoxMap</code> that uses <code>n_points</code>  Monte-Carlo test points. </p><p>Requires a CUDA-capable gpu. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/CUDAExt.jl#L239-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}" href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, :gpu, map, domain::Box{N}, points) -&gt; GPUSampledBoxMap</code></pre><p>Construct a <code>GPUSampledBoxMap</code> that uses the Vector <code>points</code> as test points.  <code>points</code> must be a VECTOR of test points within the unit cube  <code>[-1,1]^N</code>. </p><p>Requires a CUDA-capable gpu. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c3bdee97fb2ec0d07ce2992aae33e6a937522ab/ext/CUDAExt.jl#L205-L213">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_structures/">« Data Structures</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 7 March 2024 13:12">Thursday 7 March 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
